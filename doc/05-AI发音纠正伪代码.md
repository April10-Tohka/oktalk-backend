# 【阶段 5：AI 发音纠正模块核心流程伪代码】

---

## 一、接口：POST /api/v1/evaluate/submit

**功能**：用户上传朗读音频，后端异步调用讯飞评测 API，返回评测任务 ID

**流程类型**：同步 API + 异步任务处理

---

### 1.1 伪代码流程

```
流程：POST /api/v1/evaluate/submit
├─ 【同步阶段】
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 参数：audio_file（文件）、audio_type（字符串）、text_id（字符串）、
│  │  │         reference_text（字符串，可选）、language（字符串，可选）、
│  │  │         assessment_type（字符串，可选）
│  │  └─ 异常点：audio_file 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：参数校验
│  │  ├─ 检查 audio_file 是否为空
│  │  │  └─ 异常点：为空 → 返回 400
│  │  ├─ 检查 audio_type 是否为 ["wav", "mp3"]
│  │  │  └─ 异常点：非法格式 → 返回 400
│  │  ├─ 检查 audio_file 大小 ≤ 10MB
│  │  │  └─ 异常点：超过限制 → 返回 400
│  │  ├─ 检查 text_id 是否为空
│  │  │  └─ 异常点：为空 → 返回 400
│  │  └─ 检查 text_id 格式（应该是 text_xxxxxxx）
│  │     └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：处理默认参数
│  │  ├─ 如果 language 为空 → 设置为 "zh_CN"
│  │  ├─ 如果 assessment_type 为空 → 设置为 "sentence"
│  │  ├─ 检查 assessment_type 是否为 ["sentence", "word", "paragraph"]
│  │  │  └─ 异常点：非法类型 → 返回 400
│  │  └─ audio_duration_ms = 计算音频时长(audio_file)
│  │
│  ├─ 步骤 6：查询朗读文本
│  │  ├─ 如果 reference_text 不为空：
│  │  │  ├─ 使用传入的 reference_text
│  │  │  └─ 进行长度校验：0 < len(reference_text) ≤ 500
│  │  │     └─ 异常点：长度不合法 → 返回 400
│  │  ├─ 否则（reference_text 为空）：
│  │  │  ├─ 调用 Database.GetTextByID(text_id)
│  │  │  ├─ 返回：text_record（包含 content、language、category 等）
│  │  │  └─ 异常点：
│  │  │     ├─ 文本不存在 → 返回 404
│  │  │     └─ 查询失败 → 返回 500
│  │  └─ reference_text = text_record.content
│  │
│  ├─ 步骤 7：速率限制检查
│  │  ├─ 调用 RateLimiter.CheckLimit(user_id, "evaluate_submit", 限制=20/分钟)
│  │  └─ 异常点：超过限制 → 返回 429 Too Many Requests
│  │
│  ├─ 步骤 8：保存音频文件到对象存储（OSS）
│  │  ├─ 生成唯一文件名：eval_{timestamp}_{random}.{audio_type}
│  │  ├─ 调用 OSS.Upload(audio_file, 文件路径)
│  │  │  ├─ 第三方 API 调用点：阿里云 OSS / AWS S3
│  │  │  └─ 异常点：上传失败 → 返回 503 Service Unavailable
│  │  └─ audio_url = OSS 返回的文件 URL
│  │
│  ├─ 步骤 9：生成评测 ID
│  │  ├─ eval_id = "eval_" + timestamp + "_" + random_string
│  │  └─ 生成方式：UUID 或 Snowflake ID
│  │
│  ├─ 步骤 10：创建初始评测状态记录
│  │  ├─ 构建评测对象：
│  │  │  ├─ eval_id
│  │  │  ├─ status = "pending"
│  │  │  ├─ user_id
│  │  │  ├─ text_id
│  │  │  ├─ reference_text
│  │  │  ├─ audio_url
│  │  │  ├─ audio_type
│  │  │  ├─ audio_duration_ms
│  │  │  ├─ language
│  │  │  ├─ assessment_type
│  │  │  ├─ created_at = now
│  │  │  ├─ updated_at = now
│  │  │  ├─ retry_count = 0
│  │  │  └─ max_retries = 3
│  │  ├─ 调用 Cache.SetEvalStatus(eval_id, 评测对象)
│  │  │  ├─ 存储位置：Redis (TTL = 10 分钟)
│  │  │  └─ 异常点：Redis 连接失败 → 返回 503
│  │  └─ 同时保存到数据库（异步）
│  │
│  ├─ 步骤 11：将任务推送到异步队列
│  │  ├─ 调用 Queue.PushTask(评测对象)
│  │  │  ├─ 存储位置：Redis List (EvalQueue)
│  │  │  ├─ 队列键：task:queue:evaluate
│  │  │  └─ 异常点：队列满 → 返回 503
│  │  └─ 验证推送成功 → 检查返回值
│  │
│  ├─ 步骤 12：更新用户学习进度
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "eval_submission_count", 1)
│  │  └─ 异常点：Redis 操作失败 → 记录但不中断
│  │
│  ├─ 步骤 13：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      eval_id: "eval_20240115_abc123def456",
│  │  │      text_id: "text_12345",
│  │  │      status: "pending",
│  │  │      message: "发音评测任务已提交，请轮询查询结果"
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 14：返回响应
│     └─ 返回 JSON 响应给客户端
│
├─ 【异步阶段】（由 Worker Pool 处理，不阻塞主流程）
│  │
│  ├─ Worker 线程从队列中拉取任务
│  │  ├─ 调用 Queue.PopTask("evaluate", timeout=30s)
│  │  └─ 返回评测对象
│  │
│  ├─ 步骤 A1：下载音频文件
│  │  ├─ 更新评测状态：status = "processing", progress = 10%
│  │  ├─ 调用 OSS.Download(audio_url, local_path)
│  │  │  ├─ 第三方 API 调用点：阿里云 OSS
│  │  │  └─ 异常点：下载失败 → status = "failed", error = "音频下载失败"
│  │  └─ audio_data = 本地文件数据
│  │
│  ├─ 步骤 A2：调用讯飞语音评测 API
│  │  ├─ 更新评测状态：progress = 50%, current_stage = "evaluating"
│  │  ├─ 调用第三方语音评测 API
│  │  │  ├─ 第三方 API 调用点：科大讯飞语音评测 API
│  │  │  ├─ 请求参数：
│  │  │  │  ├─ audio_data（二进制音频数据）
│  │  │  │  ├─ reference_text（标准文本）
│  │  │  │  ├─ language（语言代码）
│  │  │  │  ├─ assessment_type（评测类型）
│  │  │  │  ├─ timeout = 30s
│  │  │  │  └─ api_key = 讯飞 API KEY
│  │  │  ├─ 异常处理：
│  │  │  │  ├─ 超时 → 重试 3 次（指数退避）
│  │  │  │  ├─ API 认证失败 → status = "failed", error = "API 认证失败"
│  │  │  │  ├─ 音频质量问题 → status = "failed", error = "音频质量过低"
│  │  │  │  ├─ 网络错误 → 重试 3 次
│  │  │  │  └─ API 错误 → status = "failed", error = "评测服务异常"
│  │  │  └─ 返回：评测结果对象，包含：
│  │  │     ├─ overall_score（总体得分 0-100）
│  │  │     ├─ pronunciation_score（发音得分）
│  │  │     ├─ fluency_score（流利度得分）
│  │  │     ├─ integrity_score（完整性得分）
│  │  │     ├─ phoneme_details[]（音素级详细信息）
│  │  │     │  ├─ phoneme（音素/拼音）
│  │  │     │  ├─ text（对应汉字）
│  │  │     │  ├─ score（该音素得分）
│  │  │     │  ├─ start_time_ms（起始时间）
│  │  │     │  ├─ end_time_ms（结束时间）
│  │  │     │  ├─ error_type（错误类型）
│  │  │     │  └─ suggestion（改进建议）
│  │  │     └─ raw_response（原始 API 响应）
│  │  │
│  │  └─ 异常处理：无法获取任何结果 → status = "failed"
│  │
│  ├─ 步骤 A3：后处理和分析评测结果
│  │  ├─ 更新评测状态：progress = 70%
│  │  ├─ 验证评测数据
│  │  │  ├─ 检查 overall_score 范围：0 ≤ score ≤ 100
│  │  │  ├─ 检查各子分数范围
│  │  │  └─ 异常处理：数据格式错误 → 尝试修复或标记为异常
│  │  ├─ 生成详细反馈
│  │  │  ├─ 分析 phoneme_details，找出错误音素：
│  │  │  │  ├─ error_phonemes = 筛选(score < 70)
│  │  │  │  └─ good_phonemes = 筛选(score >= 85)
│  │  │  ├─ 生成优点列表：
│  │  │  │  ├─ 如果 fluency_score >= 80 → 添加 "语调自然"
│  │  │  │  ├─ 如果 integrity_score == 100 → 添加 "发音完整"
│  │  │  │  └─ 如果有 good_phonemes → 添加 "部分音素发音准确"
│  │  │  ├─ 生成改进点列表：
│  │  │  │  ├─ 对每个 error_phoneme：
│  │  │  │  │  └─ 添加描述："{字} 发音不准，应该发音为 {标准拼音}"
│  │  │  │  └─ 如果 fluency_score < 70 → 添加 "整体流利度需要提升"
│  │  │  └─ 生成具体建议列表：
│  │  │     ├─ 对每个错误音素的 suggestion 字段使用讯飞返回的建议
│  │  │     ├─ 补充额外建议（如果需要）：
│  │  │     │  └─ "多听标准发音示范，进行对比学习"
│  │  │     └─ 最多返回 5 个建议
│  │  │
│  │  └─ 构建 detailed_feedback 对象
│  │
│  ├─ 步骤 A4：查询标准发音音频（用于对比学习）
│  │  ├─ 调用 Database.GetReferenceAudio(text_id)
│  │  ├─ 如果不存在：
│  │  │  ├─ 调用 TTS API 生成标准发音音频
│  │  │  │  ├─ 第三方 API 调用点：阿里云 CosyVoice TTS API
│  │  │  │  ├─ 上传到 OSS
│  │  │  │  └─ 保存 URL 到数据库
│  │  │  └─ 异常处理：生成失败 → reference_audio_url = null
│  │  └─ reference_audio_url = 音频 URL
│  │
│  ├─ 步骤 A5：保存评测结果到数据库
│  │  ├─ 构建评测记录对象：
│  │  │  ├─ user_id
│  │  │  ├─ text_id
│  │  │  ├─ reference_text
│  │  │  ├─ overall_score
│  │  │  ├─ scores = {
│  │  │  │    pronunciation: pronunciation_score,
│  │  │  │    fluency: fluency_score,
│  │  │  │    integrity: integrity_score
│  │  │  │  }
│  │  │  ├─ audio_url
│  │  │  ├─ audio_duration_ms
│  │  │  ├─ phonemes[]（完整音素数组）
│  │  │  ├─ detailed_feedback
│  │  │  ├─ reference_audio_url
│  │  │  ├─ raw_response（原始 API 响应，可选存储）
│  │  │  ├─ created_at
│  │  │  └─ status = "success"
│  │  ├─ 调用 Database.InsertEvalResult(评测记录)
│  │  └─ 异常处理：数据库写入失败 → 重试 3 次，最终失败记录日志
│  │
│  ├─ 步骤 A6：更新学习统计
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "eval_completion_count", 1)
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "total_eval_duration_ms", audio_duration_ms)
│  │  ├─ 调用 Cache.IncrUserStatistics(user_id, "total_eval_score_sum", overall_score)
│  │  ├─ 调用 Cache.IncrUserStatistics(user_id, "total_eval_count", 1)
│  │  └─ 异常处理：Redis 失败 → 记录但不中断
│  │
│  ├─ 步骤 A7：更新文本学习记录
│  │  ├─ 获取该文本的之前评测记录
│  │  │  └─ 调用 Database.GetTextLearnRecord(user_id, text_id)
│  │  ├─ 如果不存在：创建新的学习记录
│  │  │  └─ 调用 Database.CreateTextLearnRecord(user_id, text_id, overall_score)
│  │  ├─ 如果存在：更新学习记录
│  │  │  ├─ 计算平均分：avg_score = (old_total_score + overall_score) / (old_count + 1)
│  │  │  ├─ 判断进度：
│  │  │  │  ├─ 如果 avg_score >= 85 → learning_status = "mastered"
│  │  │  │  ├─ 如果 avg_score >= 70 → learning_status = "proficient"
│  │  │  │  └─ 否则 → learning_status = "learning"
│  │  │  └─ 调用 Database.UpdateTextLearnRecord(user_id, text_id, avg_score, learning_status)
│  │  └─ 异常处理：数据库操作失败 → 记录日志，继续
│  │
│  ├─ 步骤 A8：更新评测最终状态
│  │  ├─ 更新 Redis 中的评测状态：
│  │  │  ├─ status = "success"
│  │  │  ├─ progress = 100%
│  │  │  ├─ updated_at = now
│  │  │  └─ TTL 设置为 24 小时（用户可查询 24 小时内的结果）
│  │  ├─ 同时写入数据库（异步）
│  │  └─ 异常处理：更新失败 → 记录日志
│  │
│  ├─ 步骤 A9：触发推荐学习计划（可选）
│  │  ├─ 如果 overall_score < 70：
│  │  │  ├─ 提取错误音素列表：error_phonemes
│  │  │  ├─ 查询包含这些音素的其他学习文本
│  │  │  │  └─ 调用 Database.GetTextsByPhonemes(error_phonemes, limit=5)
│  │  │  ├─ 生成推荐学习计划
│  │  │  │  └─ 调用 LearningPlanService.GenerateRecommendation(user_id, error_phonemes, recommended_texts)
│  │  │  └─ 异常处理：推荐生成失败 → 记录日志，不影响评测
│  │  └─ 否则：跳过
│  │
│  ├─ 步骤 A10：清理资源
│  │  ├─ 释放 Worker 线程
│  │  ├─ 删除本地临时文件（audio_data）
│  │  └─ 异常处理：清理失败 → 记录警告
│  │
│  └─ 异步任务完成
│
└─ 流程结束
```

---

### 1.2 异常处理总结

| 异常点 | 阶段 | 处理方式 | 用户感知 |
|--------|------|---------|---------|
| 文件为空 | 同步 | 返回 400 | 参数错误提示 |
| Token 无效 | 同步 | 返回 401 | 需要重新登录 |
| 文件超大 | 同步 | 返回 400 | 提示文件过大 |
| text_id 不存在 | 同步 | 返回 404 | 文本不存在 |
| 速率限制 | 同步 | 返回 429 | 请求过于频繁 |
| OSS 上传失败 | 同步 | 返回 503 | 系统繁忙 |
| 讯飞 API 失败 | 异步 | 重试 3 次，失败设为 failed | 轮询时显示失败 |
| 讯飞 API 超时 | 异步 | 重试 3 次（指数退避） | 轮询时显示失败 |
| 数据库写入失败 | 异步 | 重试 3 次，最终记录日志 | 对用户无影响 |
| TTS 生成失败 | 异步 | reference_audio_url = null | 用户无标准发音对比 |

---

### 1.3 第三方 API 调用总结

| API | 提供商 | 阶段 | 超时 | 备注 |
|-----|--------|------|------|------|
| 阿里云 OSS | 阿里云 | 同步 + 异步 | 10s | 用于文件上传/下载 |
| 讯飞语音评测 | 科大讯飞 | 异步 | 30s | 核心评测服务 |
| CosyVoice | 阿里云 | 异步 | 20s | 生成标准发音（可选） |

---

## 二、接口：GET /api/v1/evaluate/result/{eval_id}

**功能**：客户端轮询查询发音评测的结果

**流程类型**：同步查询

---

### 2.1 伪代码流程

```
流程：GET /api/v1/evaluate/result/{eval_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：eval_id（字符串）
│  │  └─ 异常点：eval_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 eval_id 格式（应该是 eval_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：从 Redis 缓存查询评测状态
│  │  ├─ 调用 Cache.GetEvalStatus(eval_id)
│  │  ├─ 返回：评测对象（包含 status、progress、overall_score 等）
│  │  └─ 异常点：
│  │     ├─ Redis 连接失败 → 降级到数据库查询
│  │     └─ 评测不存在于缓存 → 继续步骤 6
│  │
│  ├─ 步骤 6：权限检查（防止用户查询他人的评测）
│  │  ├─ 如果评测不存在于缓存：
│  │  │  ├─ 调用 Database.GetEvalByID(eval_id)
│  │  │  ├─ 检查 eval.user_id == 当前登录用户的 user_id
│  │  │  └─ 异常点：
│  │  │     ├─ 评测不存在 → 返回 404 Not Found
│  │  │     └─ user_id 不匹配 → 返回 403 Forbidden
│  │  └─ 如果存在于缓存：
│  │     └─ 权限已在缓存中验证
│  │
│  ├─ 步骤 7：根据评测状态返回不同的响应
│  │  │
│  │  ├─ 【情况 A】：status == "pending"（评测等待中）
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "pending"
│  │  │  │  └─ data = {
│  │  │  │      eval_id,
│  │  │  │      status: "pending",
│  │  │  │      progress: 0,
│  │  │  │      message: "评测任务已进入队列，等待处理"
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 B】：status == "processing"（评测处理中）
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "processing"
│  │  │  │  └─ data = {
│  │  │  │      eval_id,
│  │  │  │      status: "processing",
│  │  │  │      progress: (0~100 之间的整数),
│  │  │  │      message: "正在分析音素..."
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 C】：status == "success"（评测完成成功）
│  │  │  ├─ 从缓存或数据库获取完整评测结果
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "success"
│  │  │  │  └─ data = {
│  │  │  │      eval_id,
│  │  │  │      status: "success",
│  │  │  │      text_id,
│  │  │  │      reference_text,
│  │  │  │      overall_score,
│  │  │  │      scores: {
│  │  │  │        pronunciation: pronunciation_score,
│  │  │  │        fluency: fluency_score,
│  │  │  │        integrity: integrity_score
│  │  │  │      },
│  │  │  │      duration_ms: audio_duration_ms,
│  │  │  │      phonemes: [
│  │  │  │        {
│  │  │  │          phoneme: "n",
│  │  │  │          text: "你",
│  │  │  │          score: 90.0,
│  │  │  │          start_time_ms: 0,
│  │  │  │          end_time_ms: 600
│  │  │  │        },
│  │  │  │        ...
│  │  │  │      ],
│  │  │  │      detailed_feedback: {
│  │  │  │        strengths: [],
│  │  │  │        improvements: [],
│  │  │  │        suggestions: []
│  │  │  │      },
│  │  │  │      reference_audio: reference_audio_url,
│  │  │  │      created_at
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 D】：status == "failed"（评测失败）
│  │  │  ├─ 从评测对象获取错误信息：
│  │  │  │  ├─ error_message（具体错误描述）
│  │  │  │  └─ retry_count、max_retries（重试信息）
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "failed"
│  │  │  │  └─ data = {
│  │  │  │      eval_id,
│  │  │  │      status: "failed",
│  │  │  │      error_message,
│  │  │  │      retry_count,
│  │  │  │      max_retries
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  └─ 【其他情况】：未知的状态
│  │     ├─ 记录错误日志
│  │     └─ 返回 500 Internal Server Error
│  │
│  ├─ 步骤 8：缓存优化（可选）
│  │  ├─ 如果 status == "success" 且缓存中的数据不完整
│  │  │  └─ 更新 Redis 缓存中的完整数据
│  │  └─ 异常处理：缓存更新失败 → 记录但继续
│  │
│  └─ 步骤 9：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 2.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| eval_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| eval_id 格式错误 | 返回 400 | 参数错误 |
| Redis 连接失败 | 降级到数据库 | 查询可能变慢 |
| 评测不存在 | 返回 404 | 评测不存在或已过期 |
| 权限不匹配 | 返回 403 | 无权限访问 |

---

## 三、接口：GET /api/v1/evaluate/history

**功能**：获取当前用户的评测历史列表

**流程类型**：同步查询

---

### 3.1 伪代码流程

```
流程：GET /api/v1/evaluate/history
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 查询参数：
│  │  │  ├─ text_id（字符串，可选）
│  │  │  ├─ date_from（字符串 YYYY-MM-DD，可选）
│  │  │  ├─ date_to（字符串 YYYY-MM-DD，可选）
│  │  │  ├─ page（整数，默认 1）
│  │  │  ├─ page_size（整数，默认 20，最大 100）
│  │  │  ├─ order_by（字符串，默认 "created_at"）
│  │  │  └─ order（字符串："asc" 或 "desc"，默认 "desc"）
│  │  └─ 异常点：
│  │     ├─ page 或 page_size 非法 → 返回 400
│  │     └─ 日期格式错误 → 返回 400
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：参数标准化和校验
│  │  ├─ 如果 page < 1 → 设置为 1
│  │  ├─ 如果 page_size > 100 → 设置为 100
│  │  ├─ 如果 page_size < 1 → 设置为 1
│  │  ├─ order = 转换为小写(order)
│  │  ├─ 如果 order 不是 ["asc", "desc"] → 设置为 "desc"
│  │  ├─ order_by = 转换为小写(order_by)
│  │  ├─ 如果 order_by 不是 ["created_at", "score"] → 设置为 "created_at"
│  │  ├─ offset = (page - 1) * page_size
│  │  ├─ 如果 date_from 不为空：
│  │  │  ├─ 解析为日期对象
│  │  │  └─ 异常点：日期格式错误 → 返回 400
│  │  └─ 如果 date_to 不为空：
│  │     ├─ 解析为日期对象
│  │     └─ 异常点：日期格式错误 → 返回 400
│  │
│  ├─ 步骤 5：构建查询条件
│  │  ├─ 初始化 filter = {}
│  │  ├─ filter.user_id = user_id
│  │  ├─ filter.status = "success"（只返回成功的评测）
│  │  ├─ 如果 text_id 不为空：
│  │  │  └─ filter.text_id = text_id
│  │  ├─ 如果 date_from 不为空 且 date_to 不为空：
│  │  │  ├─ filter.created_at >= date_from
│  │  │  └─ filter.created_at <= date_to + 1 天（包含结束日期的全部数据）
│  │  ├─ 否则如果仅 date_from 不为空：
│  │  │  └─ filter.created_at >= date_from
│  │  └─ 否则如果仅 date_to 不为空：
│  │     └─ filter.created_at <= date_to + 1 天
│  │
│  ├─ 步骤 6：尝试从缓存获取（如果是常见查询）
│  │  ├─ 如果 page == 1 且 order_by == "created_at" 且 order == "desc" 且无其他过滤：
│  │  │  ├─ cache_key = "eval:history:" + user_id + ":page1"
│  │  │  ├─ 调用 Cache.Get(cache_key)
│  │  │  └─ 如果命中 → 跳转到步骤 10（构建响应）
│  │  └─ 否则 → 继续步骤 7
│  │
│  ├─ 步骤 7：查询评测记录总数
│  │  ├─ 调用 Database.CountEvalRecords(filter)
│  │  ├─ 返回：total（总记录数）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 8：计算分页信息
│  │  ├─ total_pages = ceil(total / page_size)
│  │  ├─ 检查 page 是否超出范围
│  │  │  └─ 异常点：page > total_pages 且 total > 0 → 返回 400
│  │  ├─ 如果 total == 0：
│  │  │  └─ 返回空列表，total_pages = 0
│  │  └─ 继续查询数据
│  │
│  ├─ 步骤 9：从数据库查询评测记录
│  │  ├─ 调用 Database.GetEvalRecords(filter, offset, page_size, order_by, order)
│  │  ├─ 返回：eval_records 列表，每条包含：
│  │  │  ├─ eval_id
│  │  │  ├─ text_id
│  │  │  ├─ reference_text
│  │  │  ├─ overall_score
│  │  │  ├─ scores（包含 pronunciation、fluency、integrity）
│  │  │  ├─ created_at
│  │  │  └─ status
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 10：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      items: [
│  │  │        {
│  │  │          eval_id,
│  │  │          text_id,
│  │  │          reference_text,
│  │  │          overall_score,
│  │  │          scores,
│  │  │          created_at,
│  │  │          status
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      pagination: {
│  │  │        page,
│  │  │        page_size,
│  │  │        total,
│  │  │        total_pages
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 11：缓存优化
│  │  ├─ 如果是常见查询（page == 1，无过滤）
│  │  │  ├─ 调用 Cache.Set(cache_key, 响应数据, TTL=1小时)
│  │  │  └─ 异常处理：缓存设置失败 → 记录日志，继续
│  │  └─ 否则 → 跳过缓存
│  │
│  └─ 步骤 12：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 3.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| 分页参数非法 | 返回 400 | 参数错误 |
| 日期格式错误 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| 页码超出范围 | 返回 400 | 参数错误 |
| 数据库查询失败 | 返回 500 | 系统错误 |

---

## 四、接口：GET /api/v1/evaluate/{eval_id}/detail

**功能**：获取某次评测的完整详情（带详细音素分析）

**流程类型**：同步查询

---

### 4.1 伪代码流程

```
流程：GET /api/v1/evaluate/{eval_id}/detail
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：eval_id（字符串）
│  │  └─ 异常点：eval_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 eval_id 格式（应该是 eval_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：尝试从缓存获取完整评测详情
│  │  ├─ cache_key = "eval:detail:" + eval_id
│  │  ├─ 调用 Cache.Get(cache_key)
│  │  ├─ 如果命中缓存：
│  │  │  ├─ eval_record = 缓存数据
│  │  │  └─ 跳转到步骤 8（权限检查）
│  │  └─ 异常点：Redis 连接失败 → 降级到数据库查询
│  │
│  ├─ 步骤 6：从数据库查询完整评测记录
│  │  ├─ 调用 Database.GetEvalDetailByID(eval_id)
│  │  ├─ 返回：eval_record（包含所有字段，见下方说明）
│  │  └─ 异常点：
│  │     ├─ 查询失败 → 返回 500
│  │     └─ 评测不存在 → 返回 404
│  │
│  ├─ 步骤 7：权限检查
│  │  ├─ 检查 eval_record.user_id == 当前登录用户的 user_id
│  │  └─ 异常点：user_id 不匹配 → 返回 403 Forbidden
│  │
│  ├─ 步骤 8：获取补充信息（可选的丰富化）
│  │  ├─ 步骤 8.1：获取标准发音音频 URL
│  │  │  ├─ 如果 eval_record.reference_audio_url 为空：
│  │  │  │  ├─ 调用 Database.GetReferenceAudio(eval_record.text_id)
│  │  │  │  └─ 如果仍为空 → reference_audio_url = null
│  │  │  └─ 否则 → 使用现有的 URL
│  │  │
│  │  ├─ 步骤 8.2：获取用户对这个文本的学习进度
│  │  │  ├─ 调用 Database.GetTextLearnRecord(user_id, eval_record.text_id)
│  │  │  ├─ 返回：
│  │  │  │  ├─ practice_count（练习次数）
│  │  │  │  ├─ average_score（平均分）
│  │  │  │  ├─ best_score（最高分）
│  │  │  │  ├─ last_practice_at（最后练习时间）
│  │  │  │  └─ learning_status（学习状态）
│  │  │  └─ 异常处理：查询失败 → 设置为 null
│  │  │
│  │  ├─ 步骤 8.3：获取相似或相关的文本（用于推荐）
│  │  │  ├─ 提取 eval_record 中分数低于 70 的音素
│  │  │  ├─ 调用 Database.GetTextsByPhonemes(error_phonemes, limit=3)
│  │  │  ├─ 返回：recommended_texts 列表
│  │  │  └─ 异常处理：查询失败 → 设置为空数组
│  │  │
│  │  └─ 步骤 8.4：验证 URL 有效性（可选）
│  │     ├─ 对 user_audio_url 和 reference_audio_url 进行 HEAD 检查
│  │     └─ 异常处理：URL 失效 → 标记为 "expired"（不中断）
│  │
│  ├─ 步骤 9：构建详细响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      eval_id,
│  │  │      status: "success",
│  │  │      text_id,
│  │  │      reference_text,
│  │  │      overall_score,
│  │  │      scores: {
│  │  │        pronunciation,
│  │  │        fluency,
│  │  │        integrity
│  │  │      },
│  │  │      duration_ms,
│  │  │      phonemes: [
│  │  │        {
│  │  │          phoneme,
│  │  │          text,
│  │  │          score,
│  │  │          start_time_ms,
│  │  │          end_time_ms,
│  │  │          error_type,（可选）
│  │  │          suggestion（可选）
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      detailed_feedback: {
│  │  │        strengths: [],
│  │  │        improvements: [],
│  │  │        suggestions: []
│  │  │      },
│  │  │      reference_audio,
│  │  │      user_audio,
│  │  │      learning_progress: {
│  │  │        practice_count,
│  │  │        average_score,
│  │  │        best_score,
│  │  │        last_practice_at,
│  │  │        learning_status
│  │  │      },
│  │  │      recommended_texts: [
│  │  │        {
│  │  │          text_id,
│  │  │          content,
│  │  │          category,
│  │  │          reason: "包含难点音素 'x'"
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      created_at
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 10：缓存完整详情
│  │  ├─ 调用 Cache.Set(cache_key, 响应数据, TTL=4小时)
│  │  │  └─ TTL 较长是因为详情页访问频率较低且数据变化不大
│  │  └─ 异常处理：缓存设置失败 → 记录日志，继续
│  │
│  ├─ 步骤 11：记录访问统计（可选）
│  │  ├─ 调用 Analytics.RecordAccess("eval_detail", user_id, eval_id)
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  └─ 步骤 12：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 4.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| eval_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| eval_id 格式错误 | 返回 400 | 参数错误 |
| Redis 连接失败 | 降级到数据库 | 查询可能变慢 |
| 评测不存在 | 返回 404 | 评测不存在 |
| 权限不匹配 | 返回 403 | 无权限访问 |
| 学习进度查询失败 | 设置为 null | 部分信息缺失 |
| 推荐文本查询失败 | 返回空数组 | 不显示推荐 |
| URL 验证失败 | 标记但继续 | 可能显示无法播放 |

---

## 五、接口：DELETE /api/v1/evaluate/{eval_id}

**功能**：删除指定的评测记录

**流程类型**：同步删除操作

---

### 5.1 伪代码流程

```
流程：DELETE /api/v1/evaluate/{eval_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：eval_id（字符串）
│  │  └─ 异常点：eval_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 eval_id 格式（应该是 eval_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：权限和可删除性检查
│  │  ├─ 调用 Database.GetEvalByID(eval_id)
│  │  ├─ 异常点：
│  │  │  ├─ 评测不存在 → 返回 404 Not Found
│  │  │  ├─ eval.user_id != 当前用户 ID → 返回 403 Forbidden
│  │  │  └─ 查询失败 → 返回 500
│  │  └─ eval_record = 查询结果
│  │
│  ├─ 步骤 6：获取相关信息用于后续清理
│  │  ├─ audio_url = eval_record.audio_url
│  │  ├─ reference_audio_url = eval_record.reference_audio_url
│  │  ├─ text_id = eval_record.text_id
│  │  └─ overall_score = eval_record.overall_score
│  │
│  ├─ 步骤 7：开始事务（确保数据一致性）
│  │  ├─ 调用 Database.BeginTransaction()
│  │  └─ 异常点：事务启动失败 → 返回 500
│  │
│  ├─ 步骤 8：删除数据库中的评测记录
│  │  ├─ 调用 Database.DeleteEval(eval_id)
│  │  └─ 异常点：
│  │     ├─ 删除失败 → 回滚事务，返回 500
│  │     └─ 没有影响的行（已被删除）→ 回滚事务，返回 404
│  │
│  ├─ 步骤 9：更新文本学习记录（重新计算统计）
│  │  ├─ 调用 Database.GetOtherEvalsByTextID(user_id, text_id, exclude_eval_id=eval_id)
│  │  ├─ 如果还有其他评测：
│  │  │  ├─ 重新计算平均分
│  │  │  ├─ 更新 learning_record 中的 average_score、evaluation_count
│  │  │  └─ 调用 Database.UpdateTextLearnRecord(user_id, text_id, new_avg_score)
│  │  ├─ 如果没有其他评测：
│  │  │  ├─ 删除该文本的学习记录
│  │  │  └─ 调用 Database.DeleteTextLearnRecord(user_id, text_id)
│  │  └─ 异常处理：更新失败 → 回滚事务，返回 500
│  │
│  ├─ 步骤 10：提交事务
│  │  ├─ 调用 Database.CommitTransaction()
│  │  └─ 异常点：提交失败 → 回滚，返回 500
│  │
│  ├─ 步骤 11：删除 OSS 中的音频文件（异步 + 最终一致性）
│  │  ├─ 将音频 URL 推送到删除队列
│  │  ├─ audio_urls = [audio_url]
│  │  ├─ 如果 reference_audio_url 存在且不被其他文本使用：
│  │  │  └─ audio_urls.append(reference_audio_url)
│  │  ├─ 调用 Queue.PushOSSDeleteTask(audio_urls)
│  │  │  ├─ 存储位置：Redis List (OSSDeleteQueue)
│  │  │  └─ 异步 Worker 将后续完成删除
│  │  └─ 异常处理：队列满 → 记录日志，继续（对用户无影响）
│  │
│  ├─ 步骤 12：清除 Redis 缓存
│  │  ├─ 需要清除的缓存键：
│  │  │  ├─ eval:detail:{eval_id}（评测详情）
│  │  │  ├─ eval:result:{eval_id}（评测结果）
│  │  │  ├─ eval:history:{user_id}:* （用户评测历史列表，所有分页）
│  │  │  └─ 调用 Cache.DeleteKeys(所有相关键)
│  │  └─ 异常处理：缓存删除失败 → 记录日志，继续
│  │
│  ├─ 步骤 13：更新用户统计信息
│  │  ├─ 调用 Database.DecrUserStatistics(user_id)
│  │  │  ├─ 减少 total_eval_count 1
│  │  │  ├─ 调整 total_eval_score_sum（减去 overall_score）
│  │  │  └─ 重新计算 average_eval_score = total_eval_score_sum / total_eval_count
│  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │
│  ├─ 步骤 14：更新用户日常统计
│  │  ├─ 调用 Cache.DecrDailyProgress(user_id, today_date, "eval_completion_count", 1)
│  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │
│  ├─ 步骤 15：记录审计日志
│  │  ├─ 调用 AuditLog.Record({
│  │  │  user_id,
│  │  │  action: "delete_eval",
│  │  │  eval_id,
│  │  │  text_id,
│  │  │  score: overall_score,
│  │  │  timestamp: now
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 16：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      eval_id,
│  │  │      message: "评测记录已删除"
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 17：返回响应
│     └─ 返回 JSON 响应给客户端
│
├─ 【异步阶段】（后台进行，不阻塞返回）
│  │
│  └─ OSS 文件删除
│     ├─ Worker 从队列拉取删除任务
│     ├─ 对每个 audio_url：
│     │  ├─ 调用 OSS.DeleteObject(url)
│     │  │  ├─ 第三方 API 调用点：阿里云 OSS
│     │  │  └─ 异常处理：删除失败 → 重试 3 次，最终记录日志
│     │  └─ 异常处理：URL 失效 → 跳过
│     └─ 清理完毕
│
└─ 流程结束
```

---

### 5.2 事务处理说明

```
事务流程：
├─ BeginTransaction()
├─ 【事务内操作】
│  ├─ DeleteEval(eval_id)
│  ├─ UpdateTextLearnRecord(...) 或 DeleteTextLearnRecord(...)
│  └─ [如果任何操作失败] → RollbackTransaction()
├─ CommitTransaction()
└─ [事务外操作（异步）]
   ├─ 删除 OSS 文件
   ├─ 清除 Redis 缓存
   ├─ 更新用户统计
   └─ 记录审计日志
```

---

### 5.3 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| eval_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| eval_id 格式错误 | 返回 400 | 参数错误 |
| 评测不存在 | 返回 404 | 评测不存在 |
| 权限不匹配 | 返回 403 | 无权限访问 |
| 事务启动失败 | 返回 500 | 系统错误 |
| 数据库删除失败 | 回滚事务，返回 500 | 系统错误 |
| 文本统计重新计算失败 | 回滚事务，返回 500 | 系统错误 |
| 事务提交失败 | 返回 500 | 系统错误 |
| OSS 删除失败 | 重试 3 次，记录日志 | 用户无感知 |
| 缓存清除失败 | 记录日志，继续 | 用户无感知 |
| 统计更新失败 | 记录日志，继续 | 用户无感知 |

---

## 六、接口：GET /api/v1/evaluate/reference-audio/{text_id}

**功能**：获取指定文本的标准发音音频（用于对比学习）

**流程类型**：同步查询 + 可能的异步生成

---

### 6.1 伪代码流程

```
流程：GET /api/v1/evaluate/reference-audio/{text_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：text_id（字符串）
│  │  └─ 异常点：text_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证（可选 - 根据产品需求）
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 如果 Token 存在：
│  │  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  │  └─ 异常点：Token 无效 → 返回 401
│  │  └─ 如果 Token 不存在：
│  │     └─ 允许匿名访问（根据业务设计可改为必需）
│  │
│  ├─ 步骤 3：路径参数校验
│  │  ├─ 检查 text_id 格式（应该是 text_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 4：从缓存查询标准发音 URL
│  │  ├─ cache_key = "ref_audio:" + text_id
│  │  ├─ 调用 Cache.Get(cache_key)
│  │  ├─ 如果命中：
│  │  │  ├─ audio_url = 缓存值
│  │  │  └─ 跳转到步骤 8（构建响应）
│  │  └─ 异常处理：Redis 连接失败 → 降级到数据库查询
│  │
│  ├─ 步骤 5：从数据库查询文本记录
│  │  ├─ 调用 Database.GetTextByID(text_id)
│  │  ├─ 返回：text_record（包含 content、reference_audio_url 等）
│  │  └─ 异常点：
│  │     ├─ 文本不存在 → 返回 404 Not Found
│  │     └─ 查询失败 → 返回 500
│  │
│  ├─ 步骤 6：检查标准发音是否已存在
│  │  ├─ 如果 text_record.reference_audio_url 不为空：
│  │  │  ├─ audio_url = text_record.reference_audio_url
│  │  │  ├─ 验证 URL 是否仍有效：
│  │  │  │  ├─ 调用 OSS.HeadObject(audio_url)
│  │  │  │  └─ 异常处理：对象不存在 → 设置为需要重新生成
│  │  │  └─ 如果 URL 有效 → 跳转到步骤 8
│  │  └─ 如果为空 → 继续步骤 7
│  │
│  ├─ 步骤 7：需要生成标准发音（异步 + 快速返回）
│  │  ├─ 检查是否已有生成任务在进行：
│  │  │  ├─ 调用 Cache.Get("ref_audio_gen:" + text_id)
│  │  │  ├─ 如果存在生成任务：
│  │  │  │  ├─ 返回临时响应，告知正在生成
│  │  │  │  └─ HTTP 状态码：202 Accepted
│  │  │  └─ 如果不存在 → 继续
│  │  │
│  │  ├─ 生成标准发音（标记为进行中）
│  │  │  ├─ 调用 Cache.Set("ref_audio_gen:" + text_id, "generating", TTL=5分钟)
│  │  │  ├─ 推送生成任务到队列
│  │  │  │  ├─ 调用 Queue.PushTask({
│  │  │  │  │  type: "generate_reference_audio",
│  │  │  │  │  text_id,
│  │  │  │  │  content: text_record.content,
│  │  │  │  │  language: text_record.language
│  │  │  │  │})
│  │  │  │  └─ 异常处理：推送失败 → 继续，返回响应告知无法生成
│  │  │  └─ 异常处理：缓存设置失败 → 记录日志，继续
│  │  │
│  │  ├─ 返回临时响应（202 Accepted）
│  │  │  ├─ code = 202
│  │  │  ├─ message = "generating"
│  │  │  └─ data = {
│  │  │      text_id,
│  │  │      reference_text: text_record.content,
│  │  │      message: "标准发音正在生成，请稍后再试",
│  │  │      estimated_seconds: 15
│  │  │    }
│  │  └─ 立即返回客户端
│  │
│  ├─ 【异步阶段】
│  │  │
│  │  ├─ Worker 从队列拉取生成任务
│  │  │  └─ 调用 Queue.PopTask("gen_audio", timeout=30s)
│  │  │
│  │  ├─ 步骤 A1：调用 TTS API 生成标准发音
│  │  │  ├─ 调用第三方 TTS API
│  │  │  │  ├─ 第三方 API 调用点：阿里云 CosyVoice TTS API
│  │  │  │  ├─ 请求参数：
│  │  │  │  │  ├─ text: text_record.content
│  │  │  │  │  ├─ language: text_record.language
│  │  │  │  │  ├─ voice: "native_speaker"（标准发音）
│  │  │  │  │  └─ timeout: 20s
│  │  │  │  ├─ 异常处理：
│  │  │  │  │  ├─ 超时 → 重试 2 次
│  │  │  │  │  └─ API 错误 → 记录日志，放弃
│  │  │  │  └─ 返回：audio_data（二进制数据）
│  │  │  └─ 异常处理：无法获取音频 → 标记生成失败，跳转到步骤 A4
│  │  │
│  │  ├─ 步骤 A2：上传生成的音频到 OSS
│  │  │  ├─ 生成文件名：ref_audio_{text_id}.mp3
│  │  │  ├─ 调用 OSS.Upload(audio_data, 文件路径)
│  │  │  │  ├─ 第三方 API 调用点：阿里云 OSS
│  │  │  │  └─ 异常处理：上传失败 → 重试 3 次
│  │  │  └─ audio_url = OSS 返回的 URL
│  │  │
│  │  ├─ 步骤 A3：保存标准发音 URL 到数据库
│  │  │  ├─ 调用 Database.UpdateTextReferenceAudio(text_id, audio_url)
│  │  │  └─ 异常处理：数据库更新失败 → 重试 3 次，记录日志
│  │  │
│  │  ├─ 步骤 A4：更新缓存
│  │  │  ├─ 调用 Cache.Set("ref_audio:" + text_id, audio_url, TTL=7天)
│  │  │  ├─ 删除生成中标记：Cache.Delete("ref_audio_gen:" + text_id)
│  │  │  └─ 异常处理：缓存更新失败 → 记录日志
│  │  │
│  │  └─ 异步任务完成
│  │
│  ├─ 步骤 8：构建响应体（同步阶段继续）
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      text_id,
│  │  │      reference_text: text_record.content,
│  │  │      audio_url: audio_url,
│  │  │      duration_ms: (可选，如果有) 或 null,
│  │  │      language: text_record.language
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 9：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 6.2 缓存策略说明

```
缓存键设计：
├─ "ref_audio:{text_id}" → 标准发音 URL 缓存 (TTL: 7 天)
│  └─ 说明：一旦生成成功，长期缓存，不频繁变化
└─ "ref_audio_gen:{text_id}" → 生成进行中标记 (TTL: 5 分钟)
   └─ 说明：防止并发请求重复生成，5 分钟后自动过期
```

---

### 6.3 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| text_id 为空 | 返回 400 | 参数错误 |
| Token 过期（如果需要认证） | 返回 401 | 需要重新登录 |
| text_id 格式错误 | 返回 400 | 参数错误 |
| 文本不存在 | 返回 404 | 文本不存在 |
| 标准发音 URL 失效 | 标记重新生成 | 返回 202 Accepted |
| TTS 生成失败 | 重试 2 次，记录日志 | 返回 202，稍后重试 |
| OSS 上传失败 | 重试 3 次 | 返回 202，稍后重试 |
| 数据库更新失败 | 重试 3 次，记录日志 | 对用户无影响（缓存仍有效） |
| Redis 连接失败 | 降级到数据库 | 可能变慢，但不影响功能 |

---

## 七、综合总结表

### 7.1 接口特性对比

| 接口 | 同步/异步 | 操作类型 | 关键步骤数 | 异常点数 | 第三方 API |
|------|---------|---------|----------|--------|-----------|
| POST /evaluate/submit | 同步+异步 | 创建任务 | 14 | 12 | 3 个（OSS, 讯飞, TTS） |
| GET /evaluate/result/{id} | 同步 | 查询任务 | 9 | 6 | 0 个 |
| GET /evaluate/history | 同步 | 查询列表 | 12 | 7 | 0 个 |
| GET /evaluate/{id}/detail | 同步 | 查询详情 | 12 | 9 | 1 个（URL 验证） |
| DELETE /evaluate/{id} | 同步+异步 | 删除操作 | 17 | 12 | 1 个（OSS 删除） |
| GET /evaluate/reference-audio/{id} | 同步+异步 | 查询/生成 | 9 + 4 | 10 | 2 个（TTS, OSS） |

---

### 7.2 数据存储涉及的系统

| 接口 | MySQL | Redis | OSS | 队列 |
|------|--------|-------|-----|------|
| POST /evaluate/submit | ✓ | ✓ | ✓ | ✓ |
| GET /evaluate/result/{id} | ✓ | ✓ | - | - |
| GET /evaluate/history | ✓ | ✓ | - | - |
| GET /evaluate/{id}/detail | ✓ | ✓ | - | - |
| DELETE /evaluate/{id} | ✓ | ✓ | ✓ | ✓ |
| GET /evaluate/reference-audio/{id} | ✓ | ✓ | ✓ | ✓ |

---

### 7.3 流程分类

| 流程类型 | 特点 | 对应接口 |
|---------|------|---------|
| 同步 API + 异步任务 | 立即返回任务 ID，后台处理 | POST /evaluate/submit |
| 轮询查询 | 同步查询异步任务结果 | GET /evaluate/result/{id} |
| 列表查询 | 纯查询，支持分页和过滤 | GET /evaluate/history |
| 详情查询 | 单条查询，附加丰富化信息 | GET /evaluate/{id}/detail |
| 删除操作 | 事务 + 异步清理 | DELETE /evaluate/{id} |
| 查询+异步生成 | 查询存在则返回，否则异步生成 | GET /evaluate/reference-audio/{id} |

---

## 八、关键设计决策说明

### 8.1 为什么 POST /evaluate/submit 采用异步处理？

**原因**：
1. **讯飞 API 超时**：评测服务可能需要 20-30 秒，超过 HTTP 超时
2. **避免连接占用**：异步处理可释放 HTTP 连接，提高并发能力
3. **支持重试**：异步任务失败可自动重试，无需用户干预
4. **提升用户体验**：立即返回任务 ID，不需要等待整个流程

### 8.2 为什么 DELETE /evaluate/{id} 需要事务？

**原因**：
1. **数据一致性**：删除评测同时需要更新文本学习统计
2. **防止脏数据**：确保统计信息与评测数据保持一致
3. **原子性**：从用户角度，删除操作要么完全成功，要么完全失败

### 8.3 为什么 GET /evaluate/reference-audio/{id} 返回 202？

**原因**：
1. **RESTful 规范**：202 Accepted 表示请求已接受，但还在处理中
2. **非阻塞设计**：不等待 TTS 生成完成，快速返回
3. **客户端可重试**：客户端知道音频在生成中，可定期重试
4. **减少服务压力**：避免多个并发请求都去生成同一个文本的音频

### 8.4 为什么讯飞 API 调用需要重试机制？

**原因**：
1. **网络不稳定**：API 调用可能因网络问题失败
2. **服务繁忙**：讯飞服务有时可能响应缓慢
3. **指数退避**：避免过于频繁的重试导致服务雪崩
4. **用户可接受**：允许任务失败后自动重试一定次数

### 8.5 为什么要维护两个缓存键？

**原因**：
```
"ref_audio:{text_id}" → 最终结果缓存
"ref_audio_gen:{text_id}" → 进行中标记

设计意义：
├─ 当用户第一次请求时：
│  ├─ "ref_audio:xxx" 不存在
│  ├─ 设置 "ref_audio_gen:xxx" = "generating"
│  └─ 返回 202
├─ 当第二个用户并发请求时：
│  ├─ 检查 "ref_audio_gen:xxx" 存在
│  ├─ 知道有人正在生成，不再重复生成
│  └─ 返回 202
└─ 生成完成后：
   ├─ 设置 "ref_audio:xxx" = audio_url
   ├─ 删除 "ref_audio_gen:xxx"
   └─ 下次请求直接返回缓存的 URL
```

---

## 九、性能优化建议

### 9.1 查询性能优化

| 接口 | 优化策略 |
|------|---------|
| GET /evaluate/history | 为 created_at、user_id、status 建立复合索引 |
| GET /evaluate/{id}/detail | 避免 N+1 问题，批量查询相关数据 |
| GET /evaluate/reference-audio/{id} | 缓存 7 天，命中率应很高 |

### 9.2 缓存策略总结

| 缓存键 | TTL | 更新时机 | 清除时机 |
|--------|-----|---------|---------|
| eval:detail:{eval_id} | 4 小时 | 评测完成时 | 评测删除时 |
| eval:result:{eval_id} | 24 小时 | 评测完成时 | 评测删除时 |
| eval:history:{user_id}:page1 | 1 小时 | 新评测完成时 | 新评测/删除评测时 |
| ref_audio:{text_id} | 7 天 | 首次生成完成时 | 手动更新文本时 |
| ref_audio_gen:{text_id} | 5 分钟 | 生成开始时 | 自动过期或生成完成时 |

---

## 十、伪代码规范说明

本伪代码遵循以下规范：

1. **缩进**：表示层级关系和逻辑块
2. **异常点**：标记为 `异常点：条件 → 处理`
3. **API 调用**：标记为 `第三方 API 调用点：服务名`
4. **同步 vs 异步**：在流程开始明确标注
5. **变量赋值**：使用 `变量名 = 函数()` 格式
6. **条件分支**：使用 `【情况 A】`、`【情况 B】` 等标注
7. **事务**：使用 `BeginTransaction()`、`CommitTransaction()` 等标注
8. **HTTP 状态码**：标注每个返回分支的状态码

---

**AI 发音纠正模块核心流程伪代码已完成！** 🎉