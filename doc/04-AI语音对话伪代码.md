# 【阶段 5：AI 语音对话模块核心流程伪代码】

---

## 一、接口：POST /api/v1/chat/submit

**功能**：用户上传语音文件，后端异步处理 ASR + LLM + TTS，返回任务 ID

**流程类型**：同步 API + 异步任务处理

---

### 1.1 伪代码流程

```
流程：POST /api/v1/chat/submit
├─ 【同步阶段】
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 参数：audio_file（文件）、audio_type（字符串）、session_id（字符串）、
│  │  │         user_language（字符串，可选）、topic_id（字符串，可选）
│  │  └─ 异常点：文件为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：参数校验
│  │  ├─ 检查 audio_file 是否为空
│  │  │  └─ 异常点：为空 → 返回 400 参数错误
│  │  ├─ 检查 audio_type 是否为 ["wav", "mp3"]
│  │  │  └─ 异常点：非法格式 → 返回 400
│  │  ├─ 检查 audio_file 大小 ≤ 10MB
│  │  │  └─ 异常点：超过限制 → 返回 400
│  │  └─ 检查 session_id 是否为空
│  │     └─ 异常点：为空 → 返回 400
│  │
│  ├─ 步骤 5：处理默认参数
│  │  ├─ 如果 user_language 为空 → 设置为 "zh_CN"
│  │  ├─ 如果 topic_id 为空 → 设置为 null
│  │  └─ audio_duration_ms = 计算音频时长(audio_file)
│  │
│  ├─ 步骤 6：速率限制检查
│  │  ├─ 调用 RateLimiter.CheckLimit(user_id, "chat_submit", 限制=10/分钟)
│  │  └─ 异常点：超过限制 → 返回 429 Too Many Requests
│  │
│  ├─ 步骤 7：保存音频文件到对象存储（OSS）
│  │  ├─ 生成唯一文件名：chat_{timestamp}_{random}.{audio_type}
│  │  ├─ 调用 OSS.Upload(audio_file, 文件路径)
│  │  │  ├─ 第三方 API 调用点：阿里云 OSS / AWS S3
│  │  │  └─ 异常点：上传失败 → 返回 503 Service Unavailable
│  │  └─ audio_url = OSS 返回的文件 URL
│  │
│  ├─ 步骤 8：验证会话是否存在
│  │  ├─ 调用 ChatRepository.GetSession(user_id, session_id)
│  │  ├─ 如果不存在：
│  │  │  ├─ 创建新会话
│  │  │  ├─ 调用 ChatRepository.CreateSession(user_id, session_id, created_at=now)
│  │  │  └─ 异常点：数据库写入失败 → 返回 500
│  │  └─ 如果存在：
│  │     └─ 检查会话是否超过最大消息数 → 警告但继续
│  │
│  ├─ 步骤 9：生成任务 ID
│  │  ├─ task_id = "chat_" + timestamp + "_" + random_string
│  │  └─ 生成方式：UUID 或 Snowflake ID
│  │
│  ├─ 步骤 10：创建初始任务状态记录
│  │  ├─ 构建任务对象：
│  │  │  ├─ task_id
│  │  │  ├─ status = "pending"
│  │  │  ├─ user_id
│  │  │  ├─ session_id
│  │  │  ├─ audio_url
│  │  │  ├─ audio_type
│  │  │  ├─ user_language
│  │  │  ├─ topic_id
│  │  │  ├─ created_at = now
│  │  │  ├─ updated_at = now
│  │  │  ├─ retry_count = 0
│  │  │  └─ max_retries = 3
│  │  ├─ 调用 Cache.SetTaskStatus(task_id, 任务对象)
│  │  │  ├─ 存储位置：Redis (TTL = 10 分钟)
│  │  │  └─ 异常点：Redis 连接失败 → 返回 503
│  │  └─ 同时保存到数据库（异步）
│  │
│  ├─ 步骤 11：将任务推送到异步队列
│  │  ├─ 调用 Queue.PushTask(任务对象)
│  │  │  ├─ 存储位置：Redis List (TaskQueue)
│  │  │  ├─ 队列键：task:queue:chat
│  │  │  └─ 异常点：队列满 → 返回 503
│  │  └─ 验证推送成功 → 检查返回值
│  │
│  ├─ 步骤 12：更新用户学习进度（原子操作）
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "chat_submission_count", 1)
│  │  └─ 异常点：Redis 操作失败 → 记录但不中断
│  │
│  ├─ 步骤 13：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      task_id: "chat_20240115_abc123def456",
│  │  │      session_id: "sess_20240115_xyz789",
│  │  │      status: "pending",
│  │  │      message: "语音对话任务已提交，请轮询查询结果"
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 14：返回响应
│     └─ 返回 JSON 响应给客户端
│
├─ 【异步阶段】（由 Worker Pool 处理，不阻塞主流程）
│  │
│  ├─ Worker 线程从队列中拉取任务
│  │  ├─ 调用 Queue.PopTask("chat", timeout=30s)
│  │  └─ 返回任务对象
│  │
│  ├─ 步骤 A1：ASR 语音识别（异步）
│  │  ├─ 更新任务状态：status = "processing", current_stage = "asr", progress = 20%
│  │  ├─ 下载音频文件
│  │  │  ├─ 调用 OSS.Download(audio_url)
│  │  │  └─ 异常处理：下载失败 → status = "failed", error = "音频下载失败"
│  │  ├─ 调用第三方 ASR API
│  │  │  ├─ 第三方 API 调用点：阿里云 Fun-ASR API
│  │  │  ├─ 请求参数：
│  │  │  │  ├─ audio_url
│  │  │  │  ├─ format = audio_type
│  │  │  │  ├─ language = user_language
│  │  │  │  └─ timeout = 30s
│  │  │  ├─ 异常处理：
│  │  │  │  ├─ 超时 → 重试 3 次（指数退避）
│  │  │  │  ├─ API 错误 → status = "failed", error = API 错误信息
│  │  │  │  └─ 网络错误 → 重试 3 次
│  │  │  └─ 返回：user_text（识别的文本）、confidence（置信度）
│  │  ├─ 异常处理：识别置信度 < 0.5 → 记录警告但继续
│  │  └─ 保存中间结果：
│  │     ├─ Cache.SetTaskStatus(task_id, {status="processing", user_text=...})
│  │     └─ Database 记录 ASR 结果（异步写入）
│  │
│  ├─ 步骤 A2：LLM 对话生成（异步）
│  │  ├─ 更新任务状态：progress = 50%, current_stage = "llm"
│  │  ├─ 获取对话历史（用于上下文）
│  │  │  ├─ 调用 Database.GetChatHistory(user_id, session_id, limit=10)
│  │  │  └─ 异常处理：查询失败 → 使用空历史继续
│  │  ├─ 构建 LLM 请求上下文
│  │  │  ├─ 系统提示词（System Prompt）
│  │  │  ├─ 对话历史（Chat History）
│  │  │  ├─ 当前用户输入（user_text）
│  │  │  ├─ 话题约束（如果 topic_id 存在）
│  │  │  └─ 用户语言（zh_CN / en_US）
│  │  ├─ 调用第三方 LLM API
│  │  │  ├─ 第三方 API 调用点：通义千问 Qwen3-Max API
│  │  │  ├─ 请求参数：
│  │  │  │  ├─ model = "qwen3-max"
│  │  │  │  ├─ messages = [系统提示词, 历史消息, 当前消息]
│  │  │  │  ├─ temperature = 0.7
│  │  │  │  ├─ max_tokens = 500
│  │  │  │  └─ timeout = 30s
│  │  │  ├─ 异常处理：
│  │  │  │  ├─ 超时 → 使用 fallback 回复（"我没有听清，请重新说"）
│  │  │  │  ├─ API 错误 → status = "failed", error = "AI 生成失败"
│  │  │  │  └─ 速率限制 → 重试 3 次（指数退避）
│  │  │  └─ 返回：ai_text（AI 生成的回复）
│  │  ├─ 验证生成结果
│  │  │  ├─ 检查长度：0 < len(ai_text) ≤ 500 字符
│  │  │  └─ 异常处理：长度不合法 → 截断或重新生成
│  │  └─ 保存中间结果：
│  │     └─ Cache.SetTaskStatus(task_id, {status="processing", ai_text=...})
│  │
│  ├─ 步骤 A3：TTS 语音合成（异步）
│  │  ├─ 更新任务状态：progress = 75%, current_stage = "tts"
│  │  ├─ 调用第三方 TTS API
│  │  │  ├─ 第三方 API 调用点：阿里云 CosyVoice TTS API
│  │  │  ├─ 请求参数：
│  │  │  │  ├─ text = ai_text
│  │  │  │  ├─ language = user_language
│  │  │  │  ├─ voice = "native_speaker"（默认）
│  │  │  │  ├─ speed = 1.0
│  │  │  │  └─ timeout = 20s
│  │  │  ├─ 异常处理：
│  │  │  │  ├─ 超时 → 重试 2 次
│  │  │  │  ├─ 文本过长 → 截断后重新合成
│  │  │  │  └─ API 错误 → status = "failed", error = "语音合成失败"
│  │  │  └─ 返回：audio_data（音频二进制数据）
│  │  ├─ 上传 AI 语音到 OSS
│  │  │  ├─ 生成文件名：ai_audio_{task_id}.mp3
│  │  │  ├─ 调用 OSS.Upload(audio_data, 文件路径)
│  │  │  └─ 异常处理：上传失败 → status = "failed", error = "语音保存失败"
│  │  └─ ai_audio_url = OSS 返回的 URL
│  │
│  ├─ 步骤 A4：保存对话记录到数据库
│  │  ├─ 构建对话记录对象：
│  │  │  ├─ user_id
│  │  │  ├─ session_id
│  │  │  ├─ turn（对话轮数，从数据库查询递增）
│  │  │  ├─ user_text
│  │  │  ├─ user_audio_url
│  │  │  ├─ ai_text
│  │  │  ├─ ai_audio_url
│  │  │  ├─ created_at
│  │  │  └─ feedback_rating（初始为 null）
│  │  ├─ 调用 Database.InsertChatRecord(对话记录)
│  │  └─ 异常处理：数据库写入失败 → 重试 3 次，最终失败记录日志
│  │
│  ├─ 步骤 A5：更新学习进度统计
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "chat_completion_count", 1)
│  │  ├─ 调用 Cache.IncrDailyProgress(user_id, today_date, "total_chat_duration_ms", audio_duration_ms)
│  │  └─ 异常处理：Redis 失败 → 记录但不中断任务
│  │
│  ├─ 步骤 A6：更新任务最终状态
│  │  ├─ 更新 Redis 中的任务状态：
│  │  │  ├─ status = "success"
│  │  │  ├─ progress = 100%
│  │  │  ├─ current_stage = "completed"
│  │  │  ├─ updated_at = now
│  │  │  └─ TTL 设置为 24 小时（用户可查询 24 小时内的结果）
│  │  ├─ 同时写入数据库（异步）
│  │  └─ 异常处理：更新失败 → 记录日志
│  │
│  ├─ 步骤 A7：清理资源
│  │  ├─ 释放 Worker 线程
│  │  ├─ 可选：删除本地临时文件
│  │  └─ 异常处理：清理失败 → 记录警告
│  │
│  └─ 异步任务完成
│
└─ 流程结束
```

---

### 1.2 异常处理总结

| 异常点 | 阶段 | 处理方式 | 用户感知 |
|--------|------|---------|---------|
| 文件为空 | 同步 | 返回 400 | 参数错误提示 |
| Token 无效 | 同步 | 返回 401 | 需要重新登录 |
| 文件超大 | 同步 | 返回 400 | 提示文件过大 |
| 速率限制 | 同步 | 返回 429 | 请求过于频繁 |
| OSS 上传失败 | 同步 | 返回 503 | 系统繁忙 |
| ASR API 失败 | 异步 | 重试 3 次，失败设为 failed | 轮询时显示失败 |
| LLM API 失败 | 异步 | 使用 fallback 回复 | 返回预设回复 |
| TTS API 失败 | 异步 | 重试 2 次，失败仅返回文本 | 有文本但无语音 |
| 数据库失败 | 异步 | 重试 3 次，记录日志 | 对用户无影响 |

---

### 1.3 第三方 API 调用总结

| API | 提供商 | 阶段 | 超时 | 备注 |
|-----|--------|------|------|------|
| 阿里云 OSS | 阿里云 | 同步 + 异步 | 10s | 用于文件上传/下载 |
| Fun-ASR | 阿里云 | 异步 | 30s | 语音识别 |
| Qwen3-Max | 阿里巴巴 | 异步 | 30s | LLM 对话生成 |
| CosyVoice | 阿里云 | 异步 | 20s | 语音合成 |

---

## 二、接口：GET /api/v1/chat/result/{task_id}

**功能**：客户端轮询查询语音对话的处理结果

**流程类型**：同步查询

---

### 2.1 伪代码流程

```
流程：GET /api/v1/chat/result/{task_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：task_id（字符串）
│  │  └─ 异常点：task_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 task_id 格式（应该是 chat_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：从 Redis 缓存查询任务状态
│  │  ├─ 调用 Cache.GetTaskStatus(task_id)
│  │  ├─ 返回：任务对象（包含 status、progress、user_text、ai_text、ai_audio_url 等）
│  │  └─ 异常点：
│  │     ├─ Redis 连接失败 → 降级到数据库查询
│  │     └─ 任务不存在于缓存 → 继续步骤 6
│  │
│  ├─ 步骤 6：权限检查（防止用户查询他人的任务）
│  │  ├─ 如果任务不存在于缓存：
│  │  │  ├─ 调用 Database.GetTaskByID(task_id)
│  │  │  ├─ 检查 task.user_id == 当前登录用户的 user_id
│  │  │  └─ 异常点：
│  │  │     ├─ 任务不存在 → 返回 404 Not Found
│  │  │     └─ user_id 不匹配 → 返回 403 Forbidden
│  │  └─ 如果存在于缓存：
│  │     └─ 权限已在缓存中验证，继续
│  │
│  ├─ 步骤 7：根据任务状态返回不同的响应
│  │  │
│  │  ├─ 【情况 A】：status == "pending"（任务等待中）
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "pending"
│  │  │  │  └─ data = {
│  │  │  │      task_id,
│  │  │  │      status: "pending",
│  │  │  │      progress: 0,
│  │  │  │      current_stage: "queued",
│  │  │  │      message: "任务已进入队列，等待处理"
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 B】：status == "processing"（任务处理中）
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "processing"
│  │  │  │  └─ data = {
│  │  │  │      task_id,
│  │  │  │      status: "processing",
│  │  │  │      progress: (0~100 之间的整数),
│  │  │  │      current_stage: (从任务对象获取，如 "asr" / "llm" / "tts"),
│  │  │  │      message: (对应阶段的描述，如 "正在识别语音...")
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 C】：status == "success"（任务完成成功）
│  │  │  ├─ 构建完整响应数据：
│  │  │  │  ├─ user_input = {
│  │  │  │  │  ├─ text: (从任务对象获取),
│  │  │  │  │  └─ duration_ms: (计算 end_time - start_time)
│  │  │  │  │}
│  │  │  │  ├─ ai_response = {
│  │  │  │  │  ├─ text: (从任务对象获取),
│  │  │  │  │  ├─ audio_url: (从任务对象获取),
│  │  │  │  │  └─ duration_ms: (计算语音时长)
│  │  │  │  │}
│  │  │  │  ├─ created_at: (任务创建时间),
│  │  │  │  └─ feedback_url: "/api/v1/chat/feedback"
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "success"
│  │  │  │  └─ data = {
│  │  │  │      task_id,
│  │  │  │      status: "success",
│  │  │  │      session_id: (从任务对象获取),
│  │  │  │      user_input,
│  │  │  │      ai_response,
│  │  │  │      created_at,
│  │  │  │      feedback_url
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  ├─ 【情况 D】：status == "failed"（任务失败）
│  │  │  ├─ 从任务对象获取错误信息：
│  │  │  │  ├─ error_stage: (失败的阶段，如 "asr" / "llm" / "tts"),
│  │  │  │  └─ error_message: (具体错误描述)
│  │  │  ├─ 返回响应体：
│  │  │  │  ├─ code = 200
│  │  │  │  ├─ message = "failed"
│  │  │  │  └─ data = {
│  │  │  │      task_id,
│  │  │  │      status: "failed",
│  │  │  │      error_stage,
│  │  │  │      error_message,
│  │  │  │      message: "任务处理失败，请重试或联系支持"
│  │  │  │    }
│  │  │  └─ HTTP 状态码：200 OK
│  │  │
│  │  └─ 【其他情况】：未知的状态
│  │     ├─ 记录错误日志
│  │     └─ 返回 500 Internal Server Error
│  │
│  ├─ 步骤 8：更新 Token 有效期（可选优化）
│  │  ├─ 如果距离上次刷新时间 > 1 小时
│  │  │  └─ 调用 Cache.RefreshTokenTTL(user_id)
│  │  └─ 异常处理：刷新失败 → 继续（不影响响应）
│  │
│  └─ 步骤 9：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 2.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| task_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| task_id 格式错误 | 返回 400 | 参数错误 |
| Redis 连接失败 | 降级到数据库 | 查询可能变慢 |
| 任务不存在 | 返回 404 | 任务不存在或已过期 |
| 权限不匹配 | 返回 403 | 无权限访问 |

---

## 三、接口：GET /api/v1/chat/history/{session_id}

**功能**：获取指定会话的对话历史记录

**流程类型**：同步查询

---

### 3.1 伪代码流程

```
流程：GET /api/v1/chat/history/{session_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：session_id（字符串）
│  │  ├─ 查询参数：
│  │  │  ├─ page（整数，默认 1）
│  │  │  ├─ page_size（整数，默认 20，最大 100）
│  │  │  └─ order（字符串："asc" 或 "desc"，默认 "asc"）
│  │  └─ 异常点：
│  │     ├─ session_id 为空 → 返回 400 Bad Request
│  │     └─ page 或 page_size 非法 → 返回 400
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 session_id 格式（应该是 sess_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：参数标准化
│  │  ├─ 如果 page < 1 → 设置为 1
│  │  ├─ 如果 page_size > 100 → 设置为 100
│  │  ├─ 如果 page_size < 1 → 设置为 1
│  │  ├─ order = 转换为小写(order)
│  │  ├─ 如果 order 不是 ["asc", "desc"] → 设置为 "asc"
│  │  └─ offset = (page - 1) * page_size
│  │
│  ├─ 步骤 6：权限检查（会话是否属于当前用户）
│  │  ├─ 调用 Database.GetSession(user_id, session_id)
│  │  ├─ 异常点：
│  │  │  ├─ 会话不存在 → 返回 404 Not Found
│  │  │  └─ session.user_id != 当前用户 ID → 返回 403 Forbidden
│  │  └─ 获取会话元数据（后续使用）
│  │
│  ├─ 步骤 7：查询对话记录总数（用于分页）
│  │  ├─ 调用 Database.CountChatRecords(session_id)
│  │  ├─ 返回：total（总记录数）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 8：计算分页信息
│  │  ├─ total_pages = ceil(total / page_size)
│  │  ├─ 检查 page 是否超出范围
│  │  │  └─ 异常点：page > total_pages 且 total > 0 → 返回 400
│  │  ├─ 如果 total == 0
│  │  │  └─ total_pages = 0，返回空列表
│  │  └─ 继续查询数据
│  │
│  ├─ 步骤 9：从数据库查询对话记录
│  │  ├─ 调用 Database.GetChatRecords(session_id, offset, page_size, order)
│  │  ├─ 返回：chat_records 列表
│  │  │  ├─ 每条记录包含：
│  │  │  │  ├─ turn（对话轮次）
│  │  │  │  ├─ user_text（用户文本）
│  │  │  │  ├─ user_audio_url（用户语音 URL）
│  │  │  │  ├─ ai_text（AI 回复文本）
│  │  │  │  ├─ ai_audio_url（AI 语音 URL）
│  │  │  │  └─ created_at（创建时间）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 10：验证 URL 有效性（可选优化）
│  │  ├─ 对每条记录中的音频 URL 进行检查：
│  │  │  ├─ 调用 OSS.HeadObject(url) 检查对象是否存在
│  │  │  └─ 异常处理：
│  │  │     ├─ URL 失效 → 标记为 "expired"
│  │  │     ├─ 网络超时 → 忽略（视为有效）
│  │  │     └─ OSS 错误 → 记录日志，视为有效
│  │  └─ 说明：这一步是可选的，可根据性能需求调整
│  │
│  ├─ 步骤 11：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      session_id,
│  │  │      items: [
│  │  │        {
│  │  │          turn,
│  │  │          user_text,
│  │  │          user_audio_url,
│  │  │          ai_text,
│  │  │          ai_audio_url,
│  │  │          created_at
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      pagination: {
│  │  │        page,
│  │  │        page_size,
│  │  │        total,
│  │  │        total_pages
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 12：（可选）缓存优化
│  │  ├─ 如果 order == "asc" 且 page == 1（最常见的查询）
│  │  │  └─ 将结果缓存到 Redis (TTL = 1 小时)
│  │  └─ 下次相同查询时直接返回缓存
│  │
│  └─ 步骤 13：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 3.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| session_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| 分页参数非法 | 返回 400 | 参数错误 |
| 会话不存在 | 返回 404 | 会话不存在 |
| 权限不匹配 | 返回 403 | 无权限访问 |
| 页码超出范围 | 返回 400 | 参数错误 |
| 数据库查询失败 | 返回 500 | 系统错误 |
| URL 失效 | 标记但继续 | 用户可能看到损坏的链接 |

---

## 四、接口：DELETE /api/v1/chat/session/{session_id}

**功能**：删除指定会话及其所有对话记录

**流程类型**：同步删除操作

---

### 4.1 伪代码流程

```
流程：DELETE /api/v1/chat/session/{session_id}
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 路径参数：session_id（字符串）
│  │  └─ 异常点：session_id 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验
│  │  ├─ 检查 session_id 格式（应该是 sess_xxxxxxx）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 5：权限检查
│  │  ├─ 调用 Database.GetSession(user_id, session_id)
│  │  ├─ 异常点：
│  │  │  ├─ 会话不存在 → 返回 404 Not Found
│  │  │  └─ session.user_id != 当前用户 ID → 返回 403 Forbidden
│  │  └─ 获取会话信息（用于统计和日志）
│  │
│  ├─ 步骤 6：查询会话中的对话记录数量
│  │  ├─ 调用 Database.CountChatRecords(session_id)
│  │  └─ 返回：record_count（记录数量）
│  │
│  ├─ 步骤 7：获取所有相关的音频 URL（用于后续清理）
│  │  ├─ 调用 Database.GetChatRecordsAudioUrls(session_id)
│  │  ├─ 返回：audio_urls 列表
│  │  │  ├─ 包含所有的 user_audio_url 和 ai_audio_url
│  │  └─ 异常处理：查询失败 → 继续但记录日志
│  │
│  ├─ 步骤 8：开始事务（确保数据一致性）
│  │  ├─ 调用 Database.BeginTransaction()
│  │  └─ 异常点：事务启动失败 → 返回 500
│  │
│  ├─ 步骤 9：删除数据库中的对话记录
│  │  ├─ 调用 Database.DeleteChatRecordsBySessionID(session_id)
│  │  └─ 异常点：
│  │     ├─ 删除失败 → 回滚事务，返回 500
│  │     └─ 部分删除 → 回滚事务，返回 500
│  │
│  ├─ 步骤 10：删除数据库中的会话记录
│  │  ├─ 调用 Database.DeleteSession(session_id)
│  │  └─ 异常点：删除失败 → 回滚事务，返回 500
│  │
│  ├─ 步骤 11：提交事务
│  │  ├─ 调用 Database.CommitTransaction()
│  │  └─ 异常点：提交失败 → 回滚，返回 500
│  │
│  ├─ 步骤 12：删除 OSS 中的音频文件（异步 + 最终一致性）
│  │  ├─ 将音频 URL 推送到删除队列
│  │  ├─ 调用 Queue.PushOSSDeleteTask(audio_urls)
│  │  ├─ 异步 Worker 将后续完成删除
│  │  └─ 异常处理：队列满 → 记录日志，继续（对用户无影响）
│  │
│  ├─ 步骤 13：清除 Redis 缓存
│  │  ├─ 删除会话相关的缓存键：
│  │  │  ├─ 调用 Cache.DeleteSessionCache(session_id)
│  │  │  ├─ 需要清除的键包括：
│  │  │  │  ├─ chat:history:{session_id} 的列表缓存
│  │  │  │  └─ 其他相关派生缓存
│  │  └─ 异常处理：缓存删除失败 → 记录日志，继续
│  │
│  ├─ 步骤 14：更新用户统计信息
│  │  ├─ 调用 Database.DecrUserStatistics(user_id)
│  │  │  ├─ 减少 session_count 1
│  │  │  └─ 减少 total_chat_record_count 按 record_count 数量
│  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │
│  ├─ 步骤 15：记录审计日志
│  │  ├─ 调用 AuditLog.Record({
│  │  │  user_id,
│  │  │  action: "delete_session",
│  │  │  session_id,
│  │  │  deleted_records: record_count,
│  │  │  timestamp: now
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 16：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      session_id,
│  │  │      deleted_records: record_count,
│  │  │      message: "会话已删除"
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 17：返回响应
│     └─ 返回 JSON 响应给客户端
│
├─ 【异步阶段】（后台进行，不阻塞返回）
│  │
│  └─ OSS 文件删除
│     ├─ Worker 从队列拉取删除任务
│     ├─ 对每个 audio_url：
│     │  ├─ 调用 OSS.DeleteObject(url)
│     │  │  ├─ 第三方 API 调用点：阿里云 OSS
│     │  │  └─ 异常处理：删除失败 → 重试 3 次，最终记录日志
│     │  └─ 异常处理：URL 失效 → 跳过
│     └─ 清理完毕
│
└─ 流程结束
```

---

### 4.2 事务处理说明

```
事务流程：
├─ BeginTransaction()
├─ 【事务内操作】
│  ├─ DeleteChatRecordsBySessionID(session_id)
│  ├─ DeleteSession(session_id)
│  └─ [如果任何操作失败] → RollbackTransaction()
├─ CommitTransaction()
└─ [事务外操作（异步）]
   ├─ 删除 OSS 文件
   ├─ 清除 Redis 缓存
   └─ 更新统计信息
```

**为什么这样设计？**
- 数据库操作需要强一致性，使用事务确保要么全部成功，要么全部失败
- OSS 和 Redis 操作是最终一致性，即使失败也不会导致数据不一致
- 异步操作不阻塞 HTTP 响应，提高用户体验

---

### 4.3 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| session_id 为空 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| session_id 格式错误 | 返回 400 | 参数错误 |
| 会话不存在 | 返回 404 | 会话不存在 |
| 权限不匹配 | 返回 403 | 无权限访问 |
| 事务启动失败 | 返回 500 | 系统错误 |
| 数据库删除失败 | 回滚事务，返回 500 | 系统错误 |
| 事务提交失败 | 返回 500 | 系统错误 |
| OSS 删除失败 | 重试 3 次，记录日志 | 用户无感知 |
| 缓存删除失败 | 记录日志，继续 | 用户无感知 |

---

## 五、接口：GET /api/v1/chat/sessions

**功能**：获取当前用户的所有会话列表

**流程类型**：同步查询

---

### 5.1 伪代码流程

```
流程：GET /api/v1/chat/sessions
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 查询参数：
│  │  │  ├─ page（整数，默认 1）
│  │  │  └─ page_size（整数，默认 20，最大 100）
│  │  └─ 异常点：page 或 page_size 非法 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：参数标准化
│  │  ├─ 如果 page < 1 → 设置为 1
│  │  ├─ 如果 page_size > 100 → 设置为 100
│  │  ├─ 如果 page_size < 1 → 设置为 1
│  │  └─ offset = (page - 1) * page_size
│  │
│  ├─ 步骤 5：查询会话总数
│  │  ├─ 调用 Database.CountUserSessions(user_id)
│  │  ├─ 返回：total（总会话数）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 6：计算分页信息
│  │  ├─ total_pages = ceil(total / page_size)
│  │  ├─ 检查 page 是否超出范围
│  │  │  └─ 异常点：page > total_pages 且 total > 0 → 返回 400
│  │  └─ 如果 total == 0 → 返回空列表
│  │
│  ├─ 步骤 7：查询会话列表（包含最后交互信息）
│  │  ├─ 调用 Database.GetUserSessions(user_id, offset, page_size, order_by="last_interaction_at DESC")
│  │  ├─ 返回：sessions 列表，每条包含：
│  │  │  ├─ session_id
│  │  │  ├─ created_at
│  │  │  ├─ last_interaction_at
│  │  │  ├─ last_message（最后一条消息的用户文本或 AI 回复）
│  │  │  └─ message_count（该会话中的消息总数）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 8：对每条会话进行丰富化处理
│  │  ├─ 对每个 session：
│  │  │  ├─ 步骤 8.1：验证会话是否有效
│  │  │  │  └─ 检查 last_interaction_at 是否在过去 90 天内
│  │  │  │     └─ 如果否，可选：标记为 "inactive" 或过滤掉
│  │  │  │
│  │  │  ├─ 步骤 8.2：获取最后一条消息的详情（可选）
│  │  │  │  ├─ 调用 Database.GetLastChatRecord(session_id)
│  │  │  │  ├─ 获取完整的消息内容
│  │  │  │  └─ 异常处理：查询失败 → 使用缓存的 last_message
│  │  │  │
│  │  │  ├─ 步骤 8.3：检查会话中是否有未读反馈
│  │  │  │  ├─ 调用 Database.HasUnreadFeedback(session_id)
│  │  │  │  ├─ 返回：unread_feedback_count
│  │  │  │  └─ 异常处理：查询失败 → 设置为 0
│  │  │  │
│  │  │  └─ 步骤 8.4：计算会话统计（可选优化）
│  │  │     ├─ 如果已在查询步骤 7 中包含 message_count → 跳过
│  │  │     └─ 否则调用 Database.CountChatRecords(session_id)
│  │  │
│  │  └─ 继续下一个会话
│  │
│  ├─ 步骤 9：构建响应数据
│  │  ├─ 对于每个会话，构建响应对象：
│  │  │  ├─ session_id
│  │  │  ├─ created_at
│  │  │  ├─ last_message（截断为 50 字符，含 ... 标记）
│  │  │  ├─ message_count
│  │  │  ├─ last_interaction_at
│  │  │  └─ unread_feedback_count（可选）
│  │  └─ 将所有会话对象收集到 items 数组
│  │
│  ├─ 步骤 10：排序验证
│  │  ├─ 验证会话列表按 last_interaction_at 降序排列（最近的在前）
│  │  └─ 异常处理：顺序错误 → 在内存中重新排序
│  │
│  ├─ 步骤 11：构建分页响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      items: [
│  │  │        {
│  │  │          session_id,
│  │  │          created_at,
│  │  │          last_message,
│  │  │          message_count,
│  │  │          last_interaction_at
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      pagination: {
│  │  │        page,
│  │  │        page_size,
│  │  │        total,
│  │  │        total_pages
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 12：（可选）缓存优化
│  │  ├─ 如果 page == 1（最常见的查询）
│  │  │  ├─ 将结果缓存到 Redis
│  │  │  └─ TTL = 5 分钟（考虑会话不频繁变化）
│  │  └─ 下次相同查询时直接返回缓存
│  │
│  ├─ 步骤 13：更新用户的 "最后访问时间"（可选）
│  │  ├─ 调用 Database.UpdateUserLastSeenAt(user_id, now)
│  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │
│  └─ 步骤 14：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 5.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 |
|--------|---------|---------|
| 分页参数非法 | 返回 400 | 参数错误 |
| Token 过期 | 返回 401 | 需要重新登录 |
| 页码超出范围 | 返回 400 | 参数错误 |
| 数据库查询失败（总数） | 返回 500 | 系统错误 |
| 数据库查询失败（列表） | 返回 500 | 系统错误 |
| 最后消息查询失败 | 使用缓存数据 | 可能显示过期信息 |
| 获取未读反馈失败 | 设置为 0 | 可能漏显未读反馈 |
| 排序错误 | 在内存重新排序 | 用户无感知 |

---

## 六、综合总结表

### 6.1 接口特性对比

| 接口 | 同步/异步 | 操作类型 | 关键步骤数 | 异常点数 | 第三方 API |
|------|---------|---------|----------|--------|-----------|
| POST /chat/submit | 同步+异步 | 创建任务 | 14 | 12 | 4 个（OSS, ASR, LLM, TTS） |
| GET /chat/result/{id} | 同步 | 查询任务 | 9 | 6 | 0 个 |
| GET /chat/history/{id} | 同步 | 查询列表 | 13 | 7 | 1 个（OSS URL 检查，可选） |
| DELETE /chat/session/{id} | 同步+异步 | 删除操作 | 17 | 10 | 1 个（OSS 删除） |
| GET /chat/sessions | 同步 | 查询列表 | 14 | 7 | 0 个 |

---

### 6.2 数据存储涉及的系统

| 接口 | MySQL | Redis | OSS | 队列 |
|------|--------|-------|-----|------|
| POST /chat/submit | ✓ | ✓ | ✓ | ✓ |
| GET /chat/result/{id} | ✓ | ✓ | - | - |
| GET /chat/history/{id} | ✓ | ✓ | - | - |
| DELETE /chat/session/{id} | ✓ | ✓ | ✓ | ✓ |
| GET /chat/sessions | ✓ | ✓ | - | - |

---

### 6.3 流程分类

| 流程类型 | 特点 | 对应接口 |
|---------|------|---------|
| 同步 API + 异步任务 | 立即返回任务 ID，后台处理 | POST /chat/submit |
| 轮询查询 | 同步查询异步任务结果 | GET /chat/result/{id} |
| 列表查询（简单） | 纯查询，无修改 | GET /chat/history/{id}, GET /chat/sessions |
| 删除操作 | 事务 + 异步清理 | DELETE /chat/session/{id} |

---

## 七、关键设计决策说明

### 7.1 为什么 POST /chat/submit 采用异步处理？

**原因**：
1. **避免超时**：ASR (30s) + LLM (30s) + TTS (20s) = 可能 80+ 秒，超过 HTTP 超时
2. **提高并发**：不占用 HTTP 连接，可处理更多并发请求
3. **改善用户体验**：立即返回任务 ID，不需要等待整个流程完成
4. **可重试**：异步任务失败可自动重试，不需要客户端重新上传音频

### 7.2 为什么 DELETE /chat/session 需要事务？

**原因**：
1. **数据一致性**：确保会话和其对话记录要么全部删除，要么全部保留
2. **防止脏数据**：如果删除会话成功但删除记录失败，会导致孤立记录
3. **原子性**：从用户角度，删除操作要么完全成功，要么完全失败

### 7.3 为什么要检查权限（user_id 匹配）？

**原因**：
1. **安全性**：防止用户 A 查询或删除用户 B 的数据
2. **访问控制**：确保数据隔离
3. **审计**：跟踪谁删除了什么数据

### 7.4 为什么 GET /chat/history 和 GET /chat/sessions 有缓存？

**原因**：
1. **性能**：列表查询通常不涉及实时性很强的数据
2. **降低数据库压力**：热点查询（page=1）可被缓存
3. **可接受的延迟**：5 分钟内的数据差异通常可接受
4. **缓存失效机制**：当新增/删除会话或消息时，主动清除缓存

---

## 八、伪代码规范说明

本伪代码遵循以下规范：

1. **缩进**：表示层级关系和逻辑块
2. **异常点**：标记为 `异常点：条件 → 处理`
3. **API 调用**：标记为 `第三方 API 调用点：服务名`
4. **同步 vs 异步**：在流程开始明确标注
5. **变量赋值**：使用 `变量名 = 函数()` 格式
6. **条件分支**：使用 `【情况 A】`、`【情况 B】` 等标注
7. **事务**：使用 `BeginTransaction()`、`CommitTransaction()`、`RollbackTransaction()` 标注

---

**核心流程伪代码已完成，可直接指导开发实现！** 🎉