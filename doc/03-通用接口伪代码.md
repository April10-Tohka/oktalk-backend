# 【阶段 5：通用接口核心流程伪代码】

---

## 一、接口：POST /api/v1/auth/login

**功能**：用户登录，验证身份并返回访问令牌

**流程类型**：同步操作

---

### 1.1 伪代码流程

```
流程：POST /api/v1/auth/login
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 请求体参数：
│  │  │  ├─ email（字符串）或 username（字符串）
│  │  │  ├─ password（字符串）
│  │  │  ├─ remember_me（布尔值，可选，默认 false）
│  │  │  └─ login_device（字符串，可选）：["web", "mobile_ios", "mobile_android"]
│  │  └─ 异常点：
│  │     ├─ email/username 和 password 都为空 → 返回 400 Bad Request
│  │     └─ password 为空 → 返回 400
│  │
│  ├─ 步骤 2：参数校验
│  │  ├─ 检查 email 或 username 格式
│  │  │  ├─ 如果提供 email：验证邮箱格式（RFC 5322）
│  │  │  │  └─ 异常点：格式错误 → 返回 400
│  │  │  ├─ 如果提供 username：检查长度 3-20
│  │  │  │  └─ 异常点：长度不符 → 返回 400
│  │  │  └─ 优先使用 email，若为空则使用 username
│  │  │     └─ 异常点：两者都为空 → 返回 400
│  │  ├─ 检查 password 长度
│  │  │  └─ 异常点：长度 < 6 → 返回 400
│  │  └─ 异常点：参数校验失败 → 返回 400
│  │
│  ├─ 步骤 3：速率限制检查（防暴力破解）
│  │  ├─ 定义速率限制：
│  │  │  ├─ 同一 IP 地址：20 次/小时
│  │  │  ├─ 同一账户：10 次/小时
│  │  │  ├─ 同一用户密码错误次数：5 次/15 分钟（触发临时锁定）
│  │  │  └─ 临时锁定时长：15 分钟
│  │  ├─ 获取客户端 IP：
│  │  │  ├─ 优先读取 X-Forwarded-For header
│  │  │  ├─ 否则读取 X-Real-IP header
│  │  │  └─ 最后使用 RemoteAddr
│  │  ├─ 调用 RateLimiter.CheckLimit(ip_address, "login", limit=20/小时)
│  │  │  └─ 异常点：超过 IP 限制 → 返回 429 Too Many Requests
│  │  ├─ 调用 RateLimiter.CheckLimit(account_identifier, "login", limit=10/小时)
│  │  │  └─ 异常点：超过账户限制 → 返回 429
│  │  └─ 检查账户是否被临时锁定
│  │     ├─ 调用 Cache.Get("login_lock:" + account_identifier)
│  │     └─ 异常点：账户被锁定 → 返回 429 + 剩余锁定时间
│  │
│  ├─ 步骤 4：标准化登录标识
│  │  ├─ 如果是 email：转换为小写并去除空白
│  │  └─ 如果是 username：保持原样（用户名通常大小写敏感）
│  │
│  ├─ 步骤 5：从数据库查询用户账户
│  │  ├─ 如果是 email：
│  │  │  └─ 调用 Database.GetUserByEmail(email)
│  │  ├─ 如果是 username：
│  │  │  └─ 调用 Database.GetUserByUsername(username)
│  │  ├─ 返回：user_record（包含 user_id、password_hash、salt 等）
│  │  └─ 异常点：
│  │     ├─ 用户不存在 → 返回 401 Unauthorized（故意隐藏用户不存在的信息）
│  │     ├─ 账户被禁用 → 返回 403 Forbidden
│  │     ├─ 邮箱未验证（如需要） → 返回 403 + 提示验证邮箱
│  │     └─ 查询失败 → 返回 500 Internal Server Error
│  │
│  ├─ 步骤 6：密码验证
│  │  ├─ 获取 user_record 中的 password_hash 和 salt
│  │  ├─ 调用 PasswordService.VerifyPassword(password, password_hash, salt)
│  │  │  ├─ 使用 bcrypt 或 PBKDF2 等算法
│  │  │  ├─ 返回：true/false
│  │  │  └─ 异常处理：验证过程中出错 → 返回 500
│  │  ├─ 如果密码正确 → 继续步骤 7
│  │  └─ 如果密码错误：
│  │     ├─ 步骤 6.1：增加失败计数
│  │     │  ├─ 调用 Cache.Incr("login_fail:" + account_identifier)
│  │     │  ├─ 设置 TTL = 15 分钟
│  │     │  └─ 获取当前失败次数
│  │     ├─ 步骤 6.2：检查是否达到锁定阈值
│  │     │  ├─ 如果失败次数 >= 5：
│  │     │  │  ├─ 调用 Cache.Set("login_lock:" + account_identifier, true, TTL=15分钟)
│  │     │  │  ├─ 记录安全日志：登录失败过多，账户被锁定
│  │     │  │  └─ 返回 429 + "账户已被临时锁定"
│  │     │  └─ 否则：
│  │     │     ├─ 记录安全日志：登录失败
│  │     │     └─ 返回 401 + "邮箱或密码错误"
│  │     └─ 异常处理：Cache 操作失败 → 继续（不中断）
│  │
│  ├─ 步骤 7：检查 MFA（多因素认证，可选功能）
│  │  ├─ 检查用户是否启用了 MFA：user_record.mfa_enabled
│  │  ├─ 如果启用 MFA：
│  │  │  ├─ 步骤 7.1：生成临时令牌（用于 MFA 验证）
│  │  │  │  ├─ mfa_token = JWT.Sign({
│  │  │  │  │    user_id,
│  │  │  │  │    type: "mfa_pending",
│  │  │  │  │    exp: now + 5分钟
│  │  │  │  │  }, secret)
│  │  │  │  └─ 返回 202 Accepted
│  │  │  │     ├─ code = 202
│  │  │  │     ├─ message = "mfa_required"
│  │  │  │     └─ data = {
│  │  │  │        mfa_token,
│  │  │  │        mfa_method: user_record.mfa_method（"sms" / "email" / "authenticator"）
│  │  │  │      }
│  │  │  │
│  │  │  ├─ 步骤 7.2：发送 MFA 代码
│  │  │  │  ├─ 如果 mfa_method == "sms"：
│  │  │  │  │  ├─ 生成 6 位数字验证码：mfa_code = random(100000-999999)
│  │  │  │  │  ├─ 调用第三方 SMS API 发送
│  │  │  │  │  │  ├─ 第三方 API 调用点：阿里云 SMS / 腾讯云 SMS
│  │  │  │  │  │  └─ 异常处理：发送失败 → 记录日志，但仍返回 202
│  │  │  │  │  └─ 存储验证码到 Redis：
│  │  │  │  │     ├─ cache_key = "mfa_code:" + user_id
│  │  │  │  │     ├─ value = mfa_code（加盐加密）
│  │  │  │  │     └─ TTL = 5 分钟
│  │  │  │  │
│  │  │  │  ├─ 如果 mfa_method == "email"：
│  │  │  │  │  ├─ 生成 6 位数字验证码
│  │  │  │  │  ├─ 调用 EmailService.SendMFACode(email, code)
│  │  │  │  │  │  └─ 异步发送（不阻塞）
│  │  │  │  │  └─ 存储验证码到 Redis
│  │  │  │  │
│  │  │  │  └─ 如果 mfa_method == "authenticator"：
│  │  │  │     ├─ 不需要发送，用户使用认证器应用
│  │  │  │     └─ 直接返回 202
│  │  │  │
│  │  │  └─ 流程结束（等待 MFA 验证）
│  │  │
│  │  └─ 如果未启用 MFA → 继续步骤 8
│  │
│  ├─ 步骤 8：生成访问令牌（Access Token）
│  │  ├─ 定义令牌信息：
│  │  │  ├─ user_id = user_record.user_id
│  │  │  ├─ email = user_record.email
│  │  │  ├─ username = user_record.username
│  │  │  ├─ roles = user_record.roles（例如 ["user", "premium"]）
│  │  │  ├─ permissions = 从 roles 解析（例如 ["read_chat", "generate_report"]）
│  │  │  └─ issued_at = now
│  │  ├─ 计算过期时间：
│  │  │  ├─ 如果 remember_me == true：
│  │  │  │  └─ exp = now + 30 天
│  │  │  └─ 否则：
│  │  │     └─ exp = now + 24 小时
│  │  ├─ 签署 JWT 令牌
│  │  │  ├─ access_token = JWT.Sign({
│  │  │  │    user_id,
│  │  │  │    email,
│  │  │  │    username,
│  │  │  │    roles,
│  │  │  │    permissions,
│  │  │  │    issued_at,
│  │  │  │    exp
│  │  │  │  }, secret_key)
│  │  │  └─ 异常处理：签署失败 → 返回 500
│  │  └─ 返回：access_token
│  │
│  ├─ 步骤 9：生成刷新令牌（Refresh Token）
│  │  ├─ 生成长期刷新令牌（用于获取新的访问令牌）
│  │  ├─ refresh_token = JWT.Sign({
│  │  │    user_id,
│  │  │    type: "refresh",
│  │  │    issued_at: now,
│  │  │    exp: now + 90 天（长于访问令牌）
│  │  │  }, refresh_secret_key)
│  │  ├─ 同时保存到 Redis（用于撤销）：
│  │  │  ├─ cache_key = "refresh_token:" + user_id + ":" + random_id
│  │  │  ├─ value = token_metadata（包含设备信息、发布时间等）
│  │  │  ├─ TTL = 90 天
│  │  │  └─ 异常处理：存储失败 → 记录日志，继续
│  │  └─ 返回：refresh_token
│  │
│  ├─ 步骤 10：记录登录会话
│  │  ├─ 构建会话对象：
│  │  │  ├─ session_id = UUID()
│  │  │  ├─ user_id
│  │  │  ├─ login_time = now
│  │  │  ├─ ip_address
│  │  │  ├─ user_agent（从 HTTP Header 获取）
│  │  │  ├─ login_device
│  │  │  ├─ status = "active"
│  │  │  └─ last_activity_at = now
│  │  ├─ 调用 Database.InsertSession(session_object)
│  │  │  └─ 异常处理：插入失败 → 记录日志，继续（不影响登录）
│  │  └─ 同时保存到 Redis（用于快速查询）：
│  │     ├─ cache_key = "session:" + session_id
│  │     ├─ TTL = access_token 的过期时间
│  │     └─ 异常处理：存储失败 → 记录日志
│  │
│  ├─ 步骤 11：清除失败计数（登录成功后）
│  │  ├─ 调用 Cache.Delete("login_fail:" + account_identifier)
│  │  └─ 异常处理：删除失败 → 记录日志
│  │
│  ├─ 步骤 12：更新用户最后登录时间
│  │  ├─ 调用 Database.UpdateUserLastLogin(user_id, now)
│  │  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │  └─ 同时更新 Redis 缓存中的用户信息
│  │
│  ├─ 步骤 13：记录安全日志
│  │  ├─ 调用 SecurityAudit.Log({
│  │  │  user_id,
│  │  │  action: "login",
│  │  │  ip_address,
│  │  │  user_agent,
│  │  │  login_device,
│  │  │  timestamp: now,
│  │  │  status: "success"
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 14：可选：发送登录通知
│  │  ├─ 如果需要发送登录通知给用户：
│  │  │  ├─ 构建邮件：登录成功通知 + 设备信息 + IP 地址
│  │  │  ├─ 调用 EmailService.SendLoginNotification(user_email, notification_data)
│  │  │  │  └─ 异步发送（不阻塞）
│  │  │  └─ 异常处理：发送失败 → 记录日志
│  │  └─ 异常处理：通知功能禁用 → 跳过
│  │
│  ├─ 步骤 15：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      access_token,
│  │  │      refresh_token,
│  │  │      token_type: "Bearer",
│  │  │      expires_in: (剩余秒数，例如 86400),
│  │  │      user: {
│  │  │        user_id,
│  │  │        email,
│  │  │        username,
│  │  │        avatar_url,
│  │  │        roles,
│  │  │        permissions
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 16：设置 HTTP Cookie（可选）
│  │  ├─ 如果前端需要 Cookie 存储令牌：
│  │  │  ├─ 在响应头中设置 Set-Cookie：
│  │  │  │  ├─ Name：access_token
│  │  │  │  ├─ Value：token（可选加密）
│  │  │  │  ├─ HttpOnly：true（防止 JavaScript 访问）
│  │  │  │  ├─ Secure：true（仅 HTTPS）
│  │  │  │  ├─ SameSite：Strict（CSRF 防护）
│  │  │  │  ├─ Path：/
│  │  │  │  └─ Max-Age：与 token 过期时间一致
│  │  │  └─ 异常处理：Cookie 设置失败 → 记录日志
│  │  └─ 否则跳过（使用 Authorization Header）
│  │
│  └─ 步骤 17：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 1.2 异常处理总结

| 异常点 | 阶段 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|------|---------|---------|-----------|
| 参数为空 | 同步 | 返回错误 | 参数错误提示 | 400 |
| 邮箱格式错误 | 同步 | 返回错误 | 格式错误提示 | 400 |
| 超过 IP 限制 | 同步 | 拒绝登录 | 频繁尝试提示 | 429 |
| 超过账户限制 | 同步 | 拒绝登录 | 频繁尝试提示 | 429 |
| 账户被锁定 | 同步 | 拒绝登录 | 锁定提示 + 倒计时 | 429 |
| 用户不存在 | 同步 | 返回 401 | 模糊提示 | 401 |
| 账户被禁用 | 同步 | 返回 403 | 账户禁用提示 | 403 |
| 邮箱未验证 | 同步 | 返回 403 | 验证邮箱提示 | 403 |
| 密码错误 | 同步 | 返回 401 | 模糊提示 + 锁定提示（如需要） | 401 |
| 需要 MFA | 同步 | 返回 202 | MFA 验证界面 | 202 |
| 数据库查询失败 | 同步 | 返回 500 | 系统错误提示 | 500 |
| JWT 签署失败 | 同步 | 返回 500 | 系统错误提示 | 500 |
| 会话记录失败 | 同步 | 记录日志，继续 | 正常登录 | 200 |

---

### 1.3 第三方 API 调用总结

| API | 提供商 | 阶段 | 用途 | 超时 |
|-----|--------|------|------|------|
| SMS API | 阿里云/腾讯云 | MFA 发送 | 发送验证码 | 10s |
| Email Service | 邮件服务 | 登录通知/MFA | 发送邮件 | 异步 |

---

## 二、接口：POST /api/v1/auth/register

**功能**：用户注册，创建新账户

**流程类型**：同步操作（带异步邮件验证）

---

### 2.1 伪代码流程

```
流程：POST /api/v1/auth/register
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 请求体参数：
│  │  │  ├─ email（字符串）
│  │  │  ├─ username（字符串，可选）
│  │  │  ├─ password（字符串）
│  │  │  ├─ confirm_password（字符串）
│  │  │  ├─ full_name（字符串，可选）
│  │  │  ├─ language（字符串，可选，默认 "zh_CN"）
│  │  │  ├─ agree_terms（布尔值）
│  │  │  └─ agree_privacy（布尔值）
│  │  └─ 异常点：
│  │     ├─ email 为空 → 返回 400 Bad Request
│  │     ├─ password 为空 → 返回 400
│  │     └─ 必需字段缺失 → 返回 400
│  │
│  ├─ 步骤 2：参数校验
│  │  ├─ 检查 email 格式
│  │  │  ├─ 使用正则表达式验证邮箱格式（RFC 5322）
│  │  │  └─ 异常点：格式错误 → 返回 400
│  │  ├─ 检查 username 格式（如提供）
│  │  │  ├─ 长度 3-20 字符
│  │  │  ├─ 只能包含字母、数字、下划线
│  │  │  └─ 异常点：格式错误 → 返回 400
│  │  ├─ 检查密码强度
│  │  │  ├─ 长度 ≥ 8 字符
│  │  │  ├─ 必须包含大小写字母
│  │  │  ├─ 必须包含数字
│  │  │  ├─ 必须包含特殊字符（!@#$%^&* 等）
│  │  │  └─ 异常点：密码过弱 → 返回 400 + 具体要求
│  │  ├─ 检查密码和确认密码是否匹配
│  │  │  └─ 异常点：不匹配 → 返回 400
│  │  ├─ 检查 full_name 长度
│  │  │  ├─ 长度 1-50 字符
│  │  │  └─ 异常点：长度不符 → 返回 400
│  │  ├─ 检查用户是否同意条款
│  │  │  ├─ agree_terms 必须为 true
│  │  │  ├─ agree_privacy 必须为 true
│  │  │  └─ 异常点：未同意 → 返回 400
│  │  └─ 检查 language 是否为有效值
│  │     └─ 异常点：无效值 → 返回 400
│  │
│  ├─ 步骤 3：防止滥用 - 速率限制
│  │  ├─ 定义速率限制：
│  │  │  ├─ 同一 IP 地址：5 次/小时
│  │  │  └─ 同一邮箱：1 次/小时（防止邮箱被多次注册）
│  │  ├─ 获取客户端 IP
│  │  ├─ 调用 RateLimiter.CheckLimit(ip_address, "register", limit=5/小时)
│  │  │  └─ 异常点：超过限制 → 返回 429 Too Many Requests
│  │  └─ 调用 RateLimiter.CheckLimit(email, "register", limit=1/小时)
│  │     └─ 异常点：超过限制 → 返回 429
│  │
│  ├─ 步骤 4：检查邮箱是否已注册
│  │  ├─ 标准化 email：转换为小写并去除空白
│  │  ├─ 调用 Database.GetUserByEmail(email)
│  │  └─ 异常点：
│  │     ├─ 用户已存在 → 返回 409 Conflict + "邮箱已被注册"
│  │     ├─ 查询失败 → 返回 500
│  │     └─ 否则继续
│  │
│  ├─ 步骤 5：检查 username 是否已使用（如提供）
│  │  ├─ 如果 username 不为空：
│  │  │  ├─ 调用 Database.GetUserByUsername(username)
│  │  │  └─ 异常点：
│  │  │     ├─ 用户名已存在 → 返回 409 Conflict + "用户名已被使用"
│  │  │     ├─ 查询失败 → 返回 500
│  │  │     └─ 否则继续
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 6：生成用户 ID
│  │  ├─ user_id = "user_" + timestamp + "_" + random_string
│  │  └─ 生成方式：UUID 或 Snowflake ID
│  │
│  ├─ 步骤 7：加密密码
│  │  ├─ 生成盐：salt = random(32 bytes)
│  │  ├─ 调用 PasswordService.HashPassword(password, salt)
│  │  │  ├─ 使用 bcrypt 或 PBKDF2
│  │  │  ├─ 迭代次数：bcrypt cost = 12
│  │  │  └─ 返回：password_hash
│  │  └─ 异常处理：加密失败 → 返回 500
│  │
│  ├─ 步骤 8：生成邮箱验证令牌
│  │  ├─ 生成验证令牌：verification_token = random(32 bytes)
│  │  ├─ 计算过期时间：exp_time = now + 24 小时
│  │  ├─ 保存到 Redis：
│  │  │  ├─ cache_key = "email_verify:" + user_id
│  │  │  ├─ value = verification_token（加盐加密）
│  │  │  └─ TTL = 24 小时
│  │  └─ 异常处理：Redis 操作失败 → 返回 503
│  │
│  ├─ 步骤 9：创建用户账户（数据库）
│  │  ├─ 构建用户对象：
│  │  │  ├─ user_id
│  │  │  ├─ email
│  │  │  ├─ username（如为空，使用 email 前缀或随机用户名）
│  │  │  ├─ password_hash
│  │  │  ├─ salt
│  │  │  ├─ full_name
│  │  │  ├─ avatar_url = null
│  │  │  ├─ language
│  │  │  ├─ status = "active"
│  │  │  ├─ email_verified = false（邮件验证前）
│  │  │  ├─ roles = ["user"]（默认角色）
│  │  │  ├─ created_at = now
│  │  │  ├─ updated_at = now
│  │  │  ├─ last_login_at = null
│  │  │  ├─ mfa_enabled = false
│  │  │  ├─ terms_agreed_at = now
│  │  │  ├─ privacy_agreed_at = now
│  │  │  └─ referral_code = 生成邀请码（可选）
│  │  │
│  │  ├─ 调用 Database.InsertUser(user_object)
│  │  └─ 异常点：
│  │     ├─ 邮箱已存在（并发情况）→ 返回 409
│  │     ├─ 用户名已存在（并发情况）→ 返回 409
│  │     ├─ 插入失败 → 返回 500
│  │     └─ 否则继续
│  │
│  ├─ 步骤 10：初始化用户资料
│  │  ├─ 构建用户资料对象：
│  │  │  ├─ user_id
│  │  │  ├─ learning_level = "Beginner"
│  │  │  ├─ total_learning_days = 0
│  │  │  ├─ preferred_study_time = null
│  │  │  ├─ bio = ""
│  │  │  └─ created_at = now
│  │  │
│  │  ├─ 调用 Database.InsertUserProfile(profile_object)
│  │  └─ 异常处理：插入失败 → 记录日志，继续（不中断）
│  │
│  ├─ 步骤 11：初始化学习统计
│  │  ├─ 构建统计对象：
│  │  │  ├─ user_id
│  │  │  ├─ total_eval_count = 0
│  │  │  ├─ total_chat_count = 0
│  │  │  ├─ total_eval_score_sum = 0
│  │  │  ├─ average_eval_score = 0
│  │  │  ├─ total_reports_generated = 0
│  │  │  ├─ created_at = now
│  │  │  └─ updated_at = now
│  │  │
│  │  ├─ 调用 Database.InsertUserStatistics(statistics_object)
│  │  └─ 异常处理：插入失败 → 记录日志，继续
│  │
│  ├─ 步骤 12：可选 - 应用邀请码优惠
│  │  ├─ 如果请求中包含 referral_code：
│  │  │  ├─ 验证邀请码有效性
│  │  │  │  ├─ 调用 Database.ValidateReferralCode(referral_code)
│  │  │  │  └─ 异常处理：无效或过期 → 记录日志，继续
│  │  │  ├─ 记录邀请关系
│  │  │  │  └─ 调用 Database.CreateReferral(referrer_id, user_id)
│  │  │  └─ 触发奖励流程（可选）
│  │  │     └─ 新用户可能获得优惠券、学习时长等
│  │  └─ 异常处理：处理失败 → 记录日志，继续
│  │
│  ├─ 步骤 13：缓存用户信息
│  │  ├─ 调用 Cache.SetUserProfile(user_id, user_object)
│  │  │  ├─ cache_key = "user:" + user_id
│  │  │  ├─ TTL = 24 小时
│  │  │  └─ 异常处理：缓存设置失败 → 记录日志
│  │  └─ 调用 Cache.Set("email:" + email, user_id)
│  │     └─ 快速查询（邮箱→用户ID映射）
│  │
│  ├─ 步骤 14：记录注册日志
│  │  ├─ 调用 AuditLog.Record({
│  │  │  user_id,
│  │  │  action: "register",
│  │  │  ip_address,
│  │  │  user_agent,
│  │  │  timestamp: now
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 15：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 201
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      user_id,
│  │  │      email,
│  │  │      username,
│  │  │      full_name,
│  │  │      email_verified: false,
│  │  │      message: "注册成功，请验证您的邮箱"
│  │  │    }
│  │  └─ HTTP 状态码：201 Created
│  │
│  └─ 步骤 16：返回响应
│     └─ 返回 JSON 响应给客户端
│
├─ 【异步阶段】（后台进行，不阻塞返回）
│  │
│  ├─ 步骤 A1：发送邮件验证链接
│  │  ├─ 等待 0-1 秒后开始（避免与主线程竞争）
│  │  ├─ 构建验证链接：
│  │  │  ├─ verification_url = 前端 URL + "/auth/verify" + "?user_id=" + user_id + "&token=" + verification_token
│  │  │  └─ 带有签名防篡改
│  │  ├─ 构建邮件内容：
│  │  │  ├─ 模板：欢迎 + 验证链接 + 有效期提示
│  │  │  ├─ 多语言支持：根据 language 参数选择模板
│  │  │  └─ 个性化：包含用户名/邮箱
│  │  ├─ 调用 EmailService.SendEmail({
│  │  │  to: email,
│  │  │  subject: "验证您的 AI 发音纠正平台账户",
│  │  │  template: "email_verification",
│  │  │  data: {
│  │  │    full_name,
│  │  │    verification_url,
│  │  │    expiry_hours: 24
│  │  │  }
│  │  │})
│  │  │  ├─ 异步发送（不阻塞）
│  │  │  └─ 异常处理：发送失败 → 重试 3 次
│  │  └─ 记录邮件发送日志
│  │
│  ├─ 步骤 A2：可选 - 发送欢迎通知
│  │  ├─ 发送欢迎邮件（感谢注册）
│  │  │  ├─ 包含平台功能介绍
│  │  │  ├─ 推荐入门指南
│  │  │  └─ 异步发送
│  │  └─ 异常处理：发送失败 → 记录日志
│  │
│  ├─ 步骤 A3：可选 - 触发新用户活动
│  │  ├─ 如果有新用户注册优惠活动：
│  │  │  ├─ 发放新用户优惠券
│  │  │  ├─ 推荐首个学习内容
│  │  │  └─ 异常处理：触发失败 → 记录日志
│  │  └─ 异常处理：活动不存在 → 跳过
│  │
│  └─ 异步任务完成
│
└─ 流程结束
```

---

### 2.2 异常处理总结

| 异常点 | 阶段 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|------|---------|---------|-----------|
| 参数为空 | 同步 | 返回错误 | 参数错误提示 | 400 |
| 邮箱格式错误 | 同步 | 返回错误 | 格式错误提示 | 400 |
| 密码过弱 | 同步 | 返回错误 | 密码要求提示 | 400 |
| 密码不匹配 | 同步 | 返回错误 | 密码不匹配提示 | 400 |
| 未同意条款 | 同步 | 返回错误 | 同意条款提示 | 400 |
| 超过 IP 限制 | 同步 | 拒绝注册 | 频繁尝试提示 | 429 |
| 邮箱已注册 | 同步 | 返回 409 | 邮箱已注册提示 | 409 |
| 用户名已使用 | 同步 | 返回 409 | 用户名已使用提示 | 409 |
| 密码加密失败 | 同步 | 返回 500 | 系统错误提示 | 500 |
| Redis 操作失败 | 同步 | 返回 503 | 系统繁忙提示 | 503 |
| 数据库插入失败 | 同步 | 返回 500 | 系统错误提示 | 500 |
| 并发注册冲突 | 同步 | 返回 409 | 邮箱已注册提示 | 409 |
| 邮件发送失败 | 异步 | 重试 3 次 | 用户无感知 | - |

---

### 2.3 第三方 API 调用总结

| API | 提供商 | 阶段 | 用途 | 超时 |
|-----|--------|------|------|------|
| Email Service | 邮件服务 | 异步 | 发送验证邮件和欢迎邮件 | 异步 |

---

## 三、接口：POST /api/v1/auth/logout

**功能**：用户登出，撤销令牌并清理会话

**流程类型**：同步操作

---

### 3.1 伪代码流程

```
流程：POST /api/v1/auth/logout
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 请求体参数（可选）：
│  │  │  ├─ all_devices（布尔值，可选，默认 false）
│  │  │  │  └─ 如果为 true，退出所有设备的会话
│  │  │  └─ reason（字符串，可选）：["manual", "timeout", "security", "password_change"]
│  │  └─ 异常点：无关键参数缺失
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  │  ├─ 检查 token 是否有效且未过期
│  │  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │  └─ 异常点：Token 缺失 → 返回 401
│  │
│  ├─ 步骤 3：提取用户 ID 和会话信息
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  ├─ session_id = Token.解析并获取(session_id)（如有）
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：路径参数校验（无）
│  │  └─ 该接口无路径参数
│  │
│  ├─ 步骤 5：获取当前会话信息
│  │  ├─ 如果 session_id 存在：
│  │  │  ├─ 调用 Database.GetSession(session_id)
│  │  │  ├─ 返回：session_record（包含 user_id、login_time 等）
│  │  │  └─ 异常处理：会话不存在 → 继续（可能已过期）
│  │  └─ 否则跳过（会话 ID 可能未在 token 中）
│  │
│  ├─ 步骤 6：确定登出范围
│  │  ├─ 如果 all_devices == false（默认）：
│  │  │  ├─ logout_scope = "current_session"
│  │  │  ├─ target_sessions = [session_id]（仅当前会话）
│  │  │  └─ 继续步骤 7
│  │  └─ 如果 all_devices == true：
│  │     ├─ logout_scope = "all_sessions"
│  │     ├─ 调用 Database.GetAllActiveSessions(user_id)
│  │     ├─ 返回：session_list[]（该用户的所有活跃会话）
│  │     └─ target_sessions = session_list
│  │
│  ├─ 步骤 7：撤销令牌和会话
│  │  ├─ 开始事务（确保操作一致性）
│  │  │  └─ 调用 Database.BeginTransaction()
│  │  │
│  │  ├─ 步骤 7.1：标记会话为已注销
│  │  │  ├─ 对每个 target_session：
│  │  │  │  ├─ 调用 Database.UpdateSessionStatus(session_id, "logged_out", now)
│  │  │  │  ├─ 更新字段：
│  │  │  │  │  ├─ status = "logged_out"
│  │  │  │  │  ├─ logout_time = now
│  │  │  │  │  └─ logout_reason = reason（如提供）
│  │  │  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │  │  └─ 异常点：数据库更新失败 → 回滚事务，返回 500
│  │  │
│  │  ├─ 步骤 7.2：撤销刷新令牌
│  │  │  ├─ 对每个 target_session：
│  │  │  │  ├─ 获取该会话关联的 refresh_token_id
│  │  │  │  ├─ 调用 Database.InvalidateRefreshToken(refresh_token_id)
│  │  │  │  │  ├─ 更新字段：revoked = true、revoked_at = now
│  │  │  │  │  └─ 异常处理：更新失败 → 记录日志
│  │  │  │  └─ 从 Redis 中删除令牌：
│  │  │  │     ├─ cache_key = "refresh_token:" + user_id + ":" + token_id
│  │  │  │     ├─ 调用 Cache.Delete(cache_key)
│  │  │  │     └─ 异常处理：删除失败 → 记录日志
│  │  │  └─ 异常点：大量删除失败 → 回滚事务，返回 500
│  │  │
│  │  ├─ 步骤 7.3：撤销访问令牌（将其加入黑名单）
│  │  │  ├─ 获取当前 token 的过期时间
│  │  │  ├─ token_expiry_seconds = token.exp - now
│  │  │  ├─ 将 token 加入黑名单：
│  │  │  │  ├─ cache_key = "token_blacklist:" + token_hash
│  │  │  │  ├─ value = true
│  │  │  │  ├─ TTL = token_expiry_seconds（在 token 自然过期时清除）
│  │  │  │  └─ 异常处理：添加失败 → 记录日志，继续
│  │  │  └─ 异常处理：黑名单添加失败 → 记录日志
│  │  │
│  │  └─ 提交事务
│  │     ├─ 调用 Database.CommitTransaction()
│  │     └─ 异常点：提交失败 → 回滚，返回 500
│  │
│  ├─ 步骤 8：删除 Redis 中的会话缓存
│  │  ├─ 对每个 target_session：
│  │  │  ├─ cache_key = "session:" + session_id
│  │  │  ├─ 调用 Cache.Delete(cache_key)
│  │  │  └─ 异常处理：删除失败 → 记录日志，继续
│  │  └─ 异常处理：批量删除失败 → 记录日志
│  │
│  ├─ 步骤 9：删除 HTTP Cookie（如使用 Cookie 存储令牌）
│  │  ├─ 在响应头中设置 Set-Cookie 以清除 Cookie：
│  │  │  ├─ Name：access_token
│  │  │  ├─ Value：""（空值）
│  │  │  ├─ Max-Age：0（立即过期）
│  │  │  ├─ Path：/
│  │  │  └─ Domain：（与登录时保持一致）
│  │  └─ 异常处理：Cookie 清除失败 → 记录日志
│  │
│  ├─ 步骤 10：更新用户最后登出时间
│  │  ├─ 调用 Database.UpdateUserLastLogout(user_id, now)
│  │  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │  └─ 异步更新 Redis 缓存
│  │
│  ├─ 步骤 11：记录安全日志
│  │  ├─ 调用 SecurityAudit.Log({
│  │  │  user_id,
│  │  │  action: "logout",
│  │  │  session_id,
│  │  │  logout_scope: "current_session" 或 "all_sessions",
│  │  │  ip_address,
│  │  │  user_agent,
│  │  │  reason,
│  │  │  timestamp: now,
│  │  │  status: "success"
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 12：可选 - 发送登出通知
│  │  ├─ 如果登出是由密码更改或异常活动触发的：
│  │  │  ├─ 构建邮件：登出通知 + 原因说明
│  │  │  ├─ 调用 EmailService.SendLogoutNotification(user_email, notification_data)
│  │  │  │  └─ 异步发送（不阻塞）
│  │  │  └─ 异常处理：发送失败 → 记录日志
│  │  └─ 异常处理：通知功能禁用 → 跳过
│  │
│  ├─ 步骤 13：清理本地缓存数据
│  │  ├─ 如果有用户相关的缓存数据可能需要清理：
│  │  │  ├─ 删除 user_sessions 列表的缓存
│  │  │  ├─ 删除用户权限缓存（如使用）
│  │  │  └─ 异常处理：清理失败 → 记录日志
│  │  └─ 异常处理：无需清理 → 跳过
│  │
│  ├─ 步骤 14：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      message: "退出成功",
│  │  │      logout_sessions: len(target_sessions),
│  │  │      logout_time: now
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 15：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 3.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|---------|---------|-----------|
| Token 缺失 | 返回 401 | 需要提供 Token | 401 |
| Token 无效 | 返回 401 | Token 无效 | 401 |
| Token 过期 | 返回 401 | 需要重新登录 | 401 |
| 会话不存在 | 继续（可能已过期） | 正常登出 | 200 |
| 数据库更新失败 | 回滚事务，返回 500 | 系统错误 | 500 |
| Redis 删除失败 | 记录日志，继续 | 正常登出 | 200 |
| 邮件发送失败 | 记录日志，继续 | 正常登出 | 200 |

---

### 3.3 事务处理说明

```
事务流程：
├─ BeginTransaction()
├─ 【事务内操作】
│  ├─ UpdateSessionStatus()
│  ├─ InvalidateRefreshToken()
│  └─ [如果任何操作失败] → RollbackTransaction()
├─ CommitTransaction()
└─ [事务外操作（异步）]
   ├─ 删除 Redis 会话缓存
   ├─ 删除 HTTP Cookie
   ├─ 发送登出通知
   └─ 记录安全日志
```

---

## 四、接口：POST /api/v1/auth/refresh

**功能**：使用刷新令牌获取新的访问令牌

**流程类型**：同步操作

---

### 4.1 伪代码流程

```
流程：POST /api/v1/auth/refresh
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 请求体参数：
│  │  │  └─ refresh_token（字符串）
│  │  └─ 异常点：refresh_token 为空 → 返回 400 Bad Request
│  │
│  ├─ 步骤 2：参数校验
│  │  ├─ 检查 refresh_token 格式（应该是有效的 JWT）
│  │  └─ 异常点：格式不合法 → 返回 400
│  │
│  ├─ 步骤 3：验证刷新令牌
│  │  ├─ 调用 TokenService.ValidateToken(refresh_token)
│  │  │  ├─ 验证签名
│  │  │  ├─ 检查过期时间
│  │  │  ├─ 检查 token type = "refresh"
│  │  │  └─ 异常处理：验证失败 → 返回 401 Unauthorized
│  │  ├─ 解析 token 中的信息
│  │  │  ├─ user_id = Token.解析并获取(user_id)
│  │  │  ├─ token_id = Token.解析并获取(token_id)
│  │  │  └─ 异常点：必需字段缺失 → 返回 401
│  │  │
│  │  └─ 异常处理：Token 无效或过期 → 返回 401
│  │
│  ├─ 步骤 4：检查令牌是否被撤销
│  │  ├─ 调用 Database.IsRefreshTokenRevoked(token_id)
│  │  │  ├─ 查询 revoked 字段
│  │  │  └─ 异常处理：查询失败 → 返回 500
│  │  └─ 异常点：令牌已被撤销 → 返回 401 + "Token 已过期或被撤销"
│  │
│  ├─ 步骤 5：检查刷新令牌黑名单（额外防护）
│  │  ├─ cache_key = "token_blacklist:" + token_hash
│  │  ├─ 调用 Cache.Exists(cache_key)
│  │  │  └─ 异常处理：Redis 连接失败 → 降级到数据库检查
│  │  └─ 异常点：令牌在黑名单中 → 返回 401
│  │
│  ├─ 步骤 6：防止刷新令牌滥用 - 检查频率
│  │  ├─ 定义限制：同一刷新令牌 10 次/分钟
│  │  ├─ cache_key = "token_refresh:" + token_hash
│  │  ├─ 调用 Cache.Incr(cache_key)
│  │  │  ├─ 如果不存在，初始化为 1，TTL = 60 秒
│  │  │  └─ 否则，增加计数
│  │  ├─ 获取当前计数
│  │  └─ 异常点：刷新次数 > 10 → 返回 429 Too Many Requests
│  │
│  ├─ 步骤 7：验证用户账户状态
│  │  ├─ 调用 Database.GetUserByID(user_id)
│  │  ├─ 返回：user_record
│  │  └─ 异常点：
│  │     ├─ 用户不存在 → 返回 401
│  │     ├─ 账户被禁用 → 返回 403
│  │     └─ 查询失败 → 返回 500
│  │
│  ├─ 步骤 8：生成新的访问令牌
│  │  ├─ 定义令牌信息：
│  │  │  ├─ user_id = user_record.user_id
│  │  │  ├─ email = user_record.email
│  │  │  ├─ username = user_record.username
│  │  │  ├─ roles = user_record.roles
│  │  │  ├─ permissions = 从 roles 解析
│  │  │  └─ issued_at = now
│  │  ├─ 计算过期时间：
│  │  │  ├─ 原则上使用与初始登录相同的过期时间
│  │  │  └─ exp = now + 24 小时（标准访问令牌过期时间）
│  │  ├─ 签署新 JWT 令牌
│  │  │  ├─ access_token = JWT.Sign({
│  │  │  │    user_id,
│  │  │  │    email,
│  │  │  │    username,
│  │  │  │    roles,
│  │  │  │    permissions,
│  │  │  │    issued_at,
│  │  │  │    exp
│  │  │  │  }, secret_key)
│  │  │  └─ 异常处理：签署失败 → 返回 500
│  │  └─ 返回：access_token
│  │
│  ├─ 步骤 9：可选 - 返回新的刷新令牌
│  │  ├─ 如果刷新令牌接近过期（< 7 天）：
│  │  │  ├─ 生成新的刷新令牌
│  │  │  ├─ refresh_token = JWT.Sign({
│  │  │  │    user_id,
│  │  │  │    type: "refresh",
│  │  │  │    issued_at: now,
│  │  │  │    exp: now + 90 天
│  │  │  │  }, refresh_secret_key)
│  │  │  ├─ 撤销旧的刷新令牌（可选）
│  │  │  │  ├─ 调用 Database.RevokeRefreshToken(old_token_id)
│  │  │  │  └─ 异常处理：撤销失败 → 记录日志，继续
│  │  │  └─ 返回新的刷新令牌
│  │  └─ 否则：
│  │     └─ 返回原来的刷新令牌（无需更新）
│  │
│  ├─ 步骤 10：更新会话的最后活动时间
│  │  ├─ 如果有 session_id：
│  │  │  ├─ 调用 Database.UpdateSessionLastActivity(session_id, now)
│  │  │  └─ 异常处理：更新失败 → 记录日志，继续
│  │  └─ 异常处理：无 session_id → 跳过
│  │
│  ├─ 步骤 11：可选 - 更新用户缓存
│  │  ├─ 调用 Cache.SetUserProfile(user_id, user_record)
│  │  │  ├─ TTL = 24 小时
│  │  │  └─ 异常处理：缓存设置失败 → 记录日志
│  │  └─ 异常处理：缓存操作失败 → 记录日志
│  │
│  ├─ 步骤 12：记录令牌刷新日志
│  │  ├─ 调用 AuditLog.Record({
│  │  │  user_id,
│  │  │  action: "token_refresh",
│  │  │  ip_address,
│  │  │  user_agent,
│  │  │  timestamp: now,
│  │  │  status: "success"
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 13：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      access_token,
│  │  │      refresh_token（如生成了新的）或 null,
│  │  │      token_type: "Bearer",
│  │  │      expires_in: (剩余秒数，例如 86400)
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 14：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 4.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|---------|---------|-----------|
| refresh_token 为空 | 返回 400 | 参数错误 | 400 |
| refresh_token 格式错误 | 返回 400 | 参数错误 | 400 |
| 令牌验证失败 | 返回 401 | Token 无效 | 401 |
| 令牌已过期 | 返回 401 | Token 已过期 | 401 |
| Token type 不是 refresh | 返回 401 | Token 类型错误 | 401 |
| 令牌已被撤销 | 返回 401 | Token 已被撤销 | 401 |
| 刷新频率过高 | 返回 429 | 刷新过于频繁 | 429 |
| 用户不存在 | 返回 401 | 用户不存在 | 401 |
| 账户被禁用 | 返回 403 | 账户禁用 | 403 |
| JWT 签署失败 | 返回 500 | 系统错误 | 500 |

---

## 五、接口：GET /api/v1/user/profile

**功能**：获取用户个人资料

**流程类型**：同步查询

---

### 5.1 伪代码流程

```
流程：GET /api/v1/user/profile
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 查询参数：
│  │  │  └─ include（字符串，可选）：["statistics", "settings", "all"]
│  │  └─ 异常点：无必需参数缺失
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：参数校验
│  │  ├─ 检查 include 参数是否为有效值
│  │  │  └─ 异常点：非法值 → 返回 400
│  │  └─ 确定需要返回的字段组
│  │
│  ├─ 步骤 5：从缓存查询用户资料
│  │  ├─ cache_key = "user:" + user_id
│  │  ├─ 调用 Cache.Get(cache_key)
│  │  ├─ 如果命中：
│  │  │  ├─ user_profile = 缓存数据
│  │  │  └─ 跳转到步骤 8（丰富化数据）
│  │  └─ 异常点：Redis 连接失败 → 降级到数据库查询
│  │
│  ├─ 步骤 6：从数据库查询用户资料
│  │  ├─ 调用 Database.GetUserProfile(user_id)
│  │  ├─ 返回：user_profile（包含基础个人信息）
│  │  │  ├─ user_id
│  │  │  ├─ email
│  │  │  ├─ username
│  │  │  ├─ full_name
│  │  │  ├─ avatar_url
│  │  │  ├─ bio
│  │  │  ├─ language
│  │  │  ├─ created_at
│  │  │  ├─ updated_at
│  │  │  ├─ learning_level
│  │  │  ├─ phone_number（可选）
│  │  │  ├─ birthday（可选）
│  │  │  ├─ gender（可选）
│  │  │  ├─ country（可选）
│  │  │  └─ timezone（可选）
│  │  └─ 异常点：
│  │     ├─ 用户不存在 → 返回 404 Not Found
│  │     └─ 查询失败 → 返回 500 Internal Server Error
│  │
│  ├─ 步骤 7：缓存用户资料
│  │  ├─ 调用 Cache.Set(cache_key, user_profile)
│  │  │  ├─ TTL = 24 小时
│  │  │  └─ 异常处理：缓存设置失败 → 记录日志，继续
│  │  └─ 异常处理：缓存操作失败 → 记录日志
│  │
│  ├─ 步骤 8：根据 include 参数丰富化数据
│  │  ├─ 初始化结果对象：result = user_profile
│  │  │
│  │  ├─ 步骤 8.1：包含学习统计（如请求）
│  │  │  ├─ 如果 include 包含 "statistics" 或 "all"：
│  │  │  │  ├─ 调用 Database.GetUserStatistics(user_id)
│  │  │  │  ├─ 返回：statistics{
│  │  │  │  │    total_eval_count,
│  │  │  │  │    total_chat_count,
│  │  │  │  │    total_session_count,
│  │  │  │  │    average_eval_score,
│  │  │  │  │    total_learning_hours,
│  │  │  │  │    texts_studied,
│  │  │  │  │    streak_days,
│  │  │  │  │    last_activity_at
│  │  │  │  │  }
│  │  │  │  ├─ result.statistics = statistics
│  │  │  │  └─ 异常处理：查询失败 → 使用默认值
│  │  │  └─ 否则跳过
│  │  │
│  │  ├─ 步骤 8.2：包含用户设置（如请求）
│  │  │  ├─ 如果 include 包含 "settings" 或 "all"：
│  │  │  │  ├─ 调用 Database.GetUserSettings(user_id)
│  │  │  │  ├─ 返回：settings{
│  │  │  │  │    email_notifications: true/false,
│  │  │  │  │    push_notifications: true/false,
│  │  │  │  │    sms_notifications: true/false,
│  │  │  │  │    newsletter_subscribed: true/false,
│  │  │  │  │    preferred_study_time,
│  │  │  │  │    theme: "light"/"dark",
│  │  │  │  │    language_learning_goal,
│  │  │  │  │    daily_goal_minutes,
│  │  │  │  │    mfa_enabled,
│  │  │  │  │    privacy_level: "public"/"private"/"friends_only"
│  │  │  │  │  }
│  │  │  │  ├─ result.settings = settings
│  │  │  │  └─ 异常处理：查询失败 → 使用默认值
│  │  │  └─ 否则跳过
│  │  │
│  │  └─ 异常处理：丰富化过程中失败 → 返回不完整数据但继续
│  │
│  ├─ 步骤 9：计算派生字段
│  │  ├─ 计算用户账户年龄
│  │  │  ├─ account_age_days = (now - created_at) / 86400
│  │  │  └─ result.account_age_days = account_age_days
│  │  ├─ 计算完整度评分
│  │  │  ├─ profile_completeness = 计算填充字段的百分比
│  │  │  └─ result.profile_completeness_pct = completeness
│  │  └─ 异常处理：计算失败 → 跳过
│  │
│  ├─ 步骤 10：隐藏敏感信息（可选）
│  │  ├─ 根据隐私设置隐藏某些字段
│  │  │  ├─ 如果 privacy_level == "private"：
│  │  │  │  ├─ 不返回 phone_number
│  │  │  │  ├─ 不返回 birthday
│  │  │  │  └─ 隐藏邮箱（仅显示部分）
│  │  │  └─ 否则返回完整信息
│  │  └─ 异常处理：隐藏过程失败 → 返回完整信息
│  │
│  ├─ 步骤 11：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      user_id,
│  │  │      email,
│  │  │      username,
│  │  │      full_name,
│  │  │      avatar_url,
│  │  │      bio,
│  │  │      language,
│  │  │      learning_level,
│  │  │      created_at,
│  │  │      updated_at,
│  │  │      account_age_days,
│  │  │      profile_completeness_pct,
│  │  │      
│  │  │      statistics（可选）: {
│  │  │        total_eval_count,
│  │  │        total_chat_count,
│  │  │        average_eval_score,
│  │  │        total_learning_hours,
│  │  │        streak_days,
│  │  │        last_activity_at
│  │  │      },
│  │  │      
│  │  │      settings（可选）: {
│  │  │        email_notifications,
│  │  │        push_notifications,
│  │  │        preferred_study_time,
│  │  │        theme,
│  │  │        language_learning_goal
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 12：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 5.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|---------|---------|-----------|
| Token 过期 | 返回 401 | 需要重新登录 | 401 |
| include 参数无效 | 返回 400 | 参数错误 | 400 |
| Redis 连接失败 | 降级到数据库 | 查询可能变慢 | 200 |
| 用户不存在 | 返回 404 | 用户不存在 | 404 |
| 数据库查询失败 | 返回 500 | 系统错误 | 500 |
| 丰富化数据失败 | 返回不完整数据 | 部分数据缺失 | 200 |

---

## 六、接口：PUT /api/v1/user/profile

**功能**：更新用户个人资料

**流程类型**：同步操作

---

### 6.1 伪代码流程

```
流程：PUT /api/v1/user/profile
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 请求体参数：
│  │  │  ├─ full_name（字符串，可选）
│  │  │  ├─ username（字符串，可选）
│  │  │  ├─ bio（字符串，可选）
│  │  │  ├─ avatar_url（字符串，可选）或 avatar_file（文件）
│  │  │  ├─ phone_number（字符串，可选）
│  │  │  ├─ birthday（字符串 YYYY-MM-DD，可选）
│  │  │  ├─ gender（字符串，可选）：["male", "female", "other", "prefer_not_to_say"]
│  │  │  ├─ country（字符串，可选）
│  │  │  ├─ timezone（字符串，可选）
│  │  │  ├─ language（字符串，可选）
│  │  │  ├─ current_password（字符串）：修改密码时必需
│  │  │  ├─ new_password（字符串，可选）
│  │  │  ├─ confirm_password（字符串，可选）
│  │  │  └─ preferred_study_time（字符串，可选）：["morning", "afternoon", "evening", "night"]
│  │  └─ 异常点：无必修参数缺失（所有字段都是可选的）
│  │
│  ├─ 步骤 2：身份验证
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  └─ 异常点：Token 无效或过期 → 返回 401 Unauthorized
│  │
│  ├─ 步骤 3：提取用户 ID
│  │  ├─ user_id = Token.解析并获取(user_id)
│  │  └─ 异常点：Token 中缺少 user_id → 返回 401
│  │
│  ├─ 步骤 4：验证请求体是否为空
│  │  ├─ 如果所有字段都为空：
│  │  │  └─ 返回 400 Bad Request + "未提供任何需要更新的字段"
│  │  └─ 否则继续
│  │
│  ├─ 步骤 5：参数验证和标准化
│  │  ├─ 步骤 5.1：验证基本字段
│  │  │  ├─ 如果提供 full_name：
│  │  │  │  ├─ 检查长度 1-50 字符
│  │  │  │  └─ 异常点：长度不符 → 返回 400
│  │  │  ├─ 如果提供 username：
│  │  │  │  ├─ 检查长度 3-20 字符
│  │  │  │  ├─ 检查格式（仅字母数字下划线）
│  │  │  │  └─ 异常点：格式不符 → 返回 400
│  │  │  ├─ 如果提供 bio：
│  │  │  │  ├─ 检查长度 0-500 字符
│  │  │  │  └─ 异常点：超长 → 返回 400
│  │  │  ├─ 如果提供 phone_number：
│  │  │  │  ├─ 验证电话格式（国际格式）
│  │  │  │  └─ 异常点：格式错误 → 返回 400
│  │  │  ├─ 如果提供 birthday：
│  │  │  │  ├─ 验证日期格式
│  │  │  │  ├─ 检查年龄 >= 13 岁
│  │  │  │  └─ 异常点：格式错误或年龄过小 → 返回 400
│  │  │  ├─ 如果提供 gender：
│  │  │  │  └─ 异常点：非法值 → 返回 400
│  │  │  ├─ 如果提供 country：
│  │  │  │  ├─ 验证国家代码（ISO 3166-1）
│  │  │  │  └─ 异常点：代码无效 → 返回 400
│  │  │  └─ 如果提供 timezone：
│  │  │     ├─ 验证时区有效性
│  │  │     └─ 异常点：时区无效 → 返回 400
│  │  │
│  │  ├─ 步骤 5.2：验证密码更新
│  │  │  ├─ 如果提供 new_password：
│  │  │  │  ├─ current_password 必须提供
│  │  │  │  │  └─ 异常点：current_password 缺失 → 返回 400
│  │  │  │  ├─ 检查新密码强度
│  │  │  │  │  ├─ 长度 ≥ 8 字符
│  │  │  │  │  ├─ 大小写字母、数字、特殊字符
│  │  │  │  │  └─ 异常点：密码过弱 → 返回 400
│  │  │  │  ├─ 检查新密码与旧密码不同
│  │  │  │  │  └─ 异常点：相同 → 返回 400
│  │  │  │  ├─ 检查密码和确认密码匹配
│  │  │  │  │  └─ 异常点：不匹配 → 返回 400
│  │  │  │  └─ 标记需要验证 current_password
│  │  │  └─ 否则跳过
│  │  │
│  │  ├─ 步骤 5.3：验证头像上传
│  │  │  ├─ 如果提供 avatar_file：
│  │  │  │  ├─ 检查文件大小 ≤ 5MB
│  │  │  │  │  └─ 异常点：超大 → 返回 400
│  │  │  │  ├─ 检查文件类型：["image/jpeg", "image/png", "image/webp"]
│  │  │  │  │  └─ 异常点：非法格式 → 返回 400
│  │  │  │  └─ 标记需要上传头像
│  │  │  └─ 否则跳过
│  │  │
│  │  └─ 异常处理：多个字段验证失败 → 返回 400 + 所有错误
│  │
│  ├─ 步骤 6：验证 current_password（如需更新密码或敏感信息）
│  │  ├─ 如果需要验证密码：
│  │  │  ├─ 调用 Database.GetUserByID(user_id)
│  │  │  ├─ 获取 password_hash 和 salt
│  │  │  ├─ 调用 PasswordService.VerifyPassword(current_password, password_hash, salt)
│  │  │  │  └─ 返回：true/false
│  │  │  └─ 异常点：
│  │  │     ├─ 密码错误 → 返回 401 + "当前密码不正确"
│  │  │     └─ 验证失败 → 返回 500
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 7：检查 username 唯一性（如需修改）
│  │  ├─ 如果提供 username 且与当前 username 不同：
│  │  │  ├─ 调用 Database.GetUserByUsername(new_username)
│  │  │  └─ 异常点：
│  │  │     ├─ 用户名已存在 → 返回 409 Conflict
│  │  │     ├─ 查询失败 → 返回 500
│  │  │     └─ 否则继续
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 8：处理头像上传（如需要）
│  │  ├─ 如果提供 avatar_file：
│  │  │  ├─ 生成唯一文件名：avatar_{user_id}_{timestamp}.jpg
│  │  │  ├─ 调用 OSS.Upload(avatar_file, 文件路径)
│  │  │  │  ├─ 第三方 API 调用点：阿里云 OSS / AWS S3
│  │  │  │  └─ 异常处理：上传失败 → 返回 503 Service Unavailable
│  │  │  ├─ avatar_url = OSS 返回的文件 URL
│  │  │  └─ 可选：删除旧头像
│  │  │     ├─ 如果用户之前有头像且是自己上传的
│  │  │     ├─ 调用 OSS.DeleteObject(old_avatar_url)
│  │  │     └─ 异常处理：删除失败 → 记录日志，继续
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 9：加密新密码（如需要）
│  │  ├─ 如果提供 new_password：
│  │  │  ├─ 生成盐：salt = random(32 bytes)
│  │  │  ├─ 调用 PasswordService.HashPassword(new_password, salt)
│  │  │  │  └─ 返回：password_hash
│  │  │  └─ 异常处理：加密失败 → 返回 500
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 10：开始事务（确保更新一致性）
│  │  ├─ 调用 Database.BeginTransaction()
│  │  └─ 异常点：事务启动失败 → 返回 500
│  │
│  ├─ 步骤 11：更新用户记录
│  │  ├─ 构建更新字段对象：
│  │  │  ├─ 仅包含提供的字段
│  │  │  ├─ updated_at = now
│  │  │  └─ 如果更新了密码，同时更新：
│  │  │     ├─ password_hash
│  │  │     ├─ salt
│  │  │     └─ password_changed_at = now
│  │  ├─ 调用 Database.UpdateUser(user_id, update_fields)
│  │  └─ 异常点：
│  │     ├─ 用户不存在 → 回滚事务，返回 404
│  │     ├─ username 已被使用（并发情况）→ 回滚事务，返回 409
│  │     ├─ 更新失败 → 回滚事务，返回 500
│  │     └─ 否则继续
│  │
│  ├─ 步骤 12：更新用户资料表（如需要）
│  │  ├─ 如果提供了资料字段（bio、preferred_study_time 等）：
│  │  │  ├─ 调用 Database.UpdateUserProfile(user_id, profile_fields)
│  │  │  └─ 异常点：更新失败 → 回滚事务，返回 500
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 13：提交事务
│  │  ├─ 调用 Database.CommitTransaction()
│  │  └─ 异常点：提交失败 → 回滚，返回 500
│  │
│  ├─ 步骤 14：清除缓存
│  │  ├─ 需要清除的缓存键：
│  │  │  ├─ user:{user_id}（用户资料缓存）
│  │  │  ├─ email:{old_email}→{user_id}（如修改了邮箱）
│  │  │  └─ username:{old_username}→{user_id}（如修改了用户名）
│  │  ├─ 调用 Cache.DeleteKeys(所有相关键)
│  │  └─ 异常处理：删除失败 → 记录日志，继续
│  │
│  ├─ 步骤 15：可选 - 更新 session 中的用户信息
│  │  ├─ 如果修改了会影响权限的字段：
│  │  │  ├─ 更新 Redis 中缓存的 session 信息
│  │  │  └─ 异常处理：更新失败 → 记录日志
│  │  └─ 异常处理：无需更新 → 跳过
│  │
│  ├─ 步骤 16：如果修改了密码，撤销其他会话
│  │  ├─ 如果提供了 new_password：
│  │  │  ├─ 调用 Database.GetAllActiveSessions(user_id)
│  │  │  ├─ 对除当前 session 外的所有会话：
│  │  │  │  ├─ 调用 Database.UpdateSessionStatus(session_id, "logged_out", now)
│  │  │  │  ├─ 原因：password_changed
│  │  │  │  └─ 异常处理：更新失败 → 记录日志
│  │  │  ├─ 清除这些会话的 Redis 缓存
│  │  │  └─ 异常处理：批量更新失败 → 记录日志
│  │  └─ 否则跳过
│  │
│  ├─ 步骤 17：记录修改日志
│  │  ├─ 调用 AuditLog.Record({
│  │  │  user_id,
│  │  │  action: "profile_update",
│  │  │  changes: [
│  │  │    {field: "full_name", old_value: old_name, new_value: new_name},
│  │  │    ...（所有修改的字段）
│  │  │  ],
│  │  │  ip_address,
│  │  │  user_agent,
│  │  │  timestamp: now
│  │  │})
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  ├─ 步骤 18：可选 - 发送确认邮件
│  │  ├─ 如果修改了敏感信息（密码、邮箱等）：
│  │  │  ├─ 构建确认邮件
│  │  │  ├─ 调用 EmailService.SendProfileUpdateNotification(email, changes)
│  │  │  │  └─ 异步发送
│  │  │  └─ 异常处理：发送失败 → 记录日志
│  │  └─ 异常处理：通知功能禁用 → 跳过
│  │
│  ├─ 步骤 19：重新查询更新后的用户数据
│  │  ├─ 调用 Database.GetUserProfile(user_id)
│  │  └─ 异常处理：查询失败 → 返回 500
│  │
│  ├─ 步骤 20：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      user_id,
│  │  │      email,
│  │  │      username,
│  │  │      full_name,
│  │  │      avatar_url,
│  │  │      bio,
│  │  │      language,
│  │  │      learning_level,
│  │  │      updated_at: now,
│  │  │      password_updated: (如修改了密码) true/false,
│  │  │      profile_completeness_pct,
│  │  │      message: "个人资料已更新"
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  └─ 步骤 21：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 6.2 事务处理说明

```
事务流程：
├─ BeginTransaction()
├─ 【事务内操作】
│  ├─ UpdateUser()
│  ├─ UpdateUserProfile()（如需要）
│  └─ [如果任何操作失败] → RollbackTransaction()
├─ CommitTransaction()
└─ [事务外操作（异步）]
   ├─ 清除 Redis 缓存
   ├─ 撤销其他会话（如修改密码）
   ├─ 发送确认邮件
   └─ 记录审计日志
```

---

### 6.3 异常处理总结

| 异常点 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|---------|---------|-----------|
| Token 过期 | 返回 401 | 需要重新登录 | 401 |
| 无需更新字段 | 返回 400 | 参数错误 | 400 |
| 字段验证失败 | 返回 400 | 参数错误提示 | 400 |
| 现有密码错误 | 返回 401 | 密码错误提示 | 401 |
| 用户名已存在 | 返回 409 | 用户名冲突 | 409 |
| 文件上传失败 | 返回 503 | 系统繁忙 | 503 |
| 数据库更新失败 | 回滚事务，返回 500 | 系统错误 | 500 |
| 用户不存在 | 返回 404 | 用户不存在 | 404 |

---

## 七、接口：GET /api/v1/resources/texts

**功能**：获取学习文本库，支持搜索、过滤和分页

**流程类型**：同步查询

---

### 7.1 伪代码流程

```
流程：GET /api/v1/resources/texts
├─ 【同步阶段】
│  │
│  ├─ 步骤 1：接收 HTTP 请求
│  │  ├─ 查询参数：
│  │  │  ├─ page（整数，默认 1）
│  │  │  ├─ page_size（整数，默认 20，最大 100）
│  │  │  ├─ search（字符串，可选）
│  │  │  ├─ category（字符串，可选）：["daily", "story", "idiom", "tongue_twister", "poem"]
│  │  │  ├─ difficulty（字符串，可选）：["easy", "medium", "hard", "advanced"]
│  │  │  ├─ language（字符串，可选）：["zh_CN", "zh_TW", "en"]
│  │  │  ├─ phonemes（字符串，可选）：逗号分隔的拼音/音素列表
│  │  │  ├─ sort_by（字符串，可选）：["relevance", "difficulty", "popularity", "newest"]
│  │  │  ├─ duration_min（整数，可选）：最小朗读时长（秒）
│  │  │  ├─ duration_max（整数，可选）：最大朗读时长（秒）
│  │  │  ├─ include_learned（布尔值，可选，默认 false）
│  │  │  └─ tag（字符串，可选）：逗号分隔的标签列表
│  │  └─ 异常点：page 或 page_size 非法 → 返回 400
│  │
│  ├─ 步骤 2：身份验证（可选 - 可匿名访问或需要认证）
│  │  ├─ 从 HTTP Header 获取 Authorization Token
│  │  ├─ 如果 Token 存在：
│  │  │  ├─ 调用 TokenService.ValidateToken(token)
│  │  │  ├─ user_id = Token.解析并获取(user_id)（可选）
│  │  │  └─ 异常处理：Token 无效 → 作为匿名用户继续
│  │  └─ 否则作为匿名用户继续
│  │
│  ├─ 步骤 3：参数标准化和校验
│  │  ├─ 如果 page < 1 → 设置为 1
│  │  ├─ 如果 page_size > 100 → 设置为 100
│  │  ├─ 如果 page_size < 1 → 设置为 1
│  │  ├─ 如果提供 search → 转义特殊字符，限制长度 ≤ 50
│  │  │  └─ 异常点：过长 → 返回 400
│  │  ├─ 如果提供 category → 验证是否为有效值
│  │  │  └─ 异常点：无效值 → 返回 400
│  │  ├─ 如果提供 difficulty → 验证是否为有效值
│  │  │  └─ 异常点：无效值 → 返回 400
│  │  ├─ 如果提供 phonemes → 转换为数组，限制数量 ≤ 10
│  │  │  └─ 异常点：超过数量限制 → 返回 400
│  │  ├─ 如果提供 duration_min 和 duration_max：
│  │  │  ├─ 检查 duration_min <= duration_max
│  │  │  └─ 异常点：不符合 → 返回 400
│  │  └─ offset = (page - 1) * page_size
│  │
│  ├─ 步骤 4：尝试从缓存获取（常见查询）
│  │  ├─ 生成缓存键：
│  │  │  ├─ 基础键 = "texts:list"
│  │  │  ├─ 包含所有查询参数的哈希值
│  │  │  └─ cache_key = "texts:list:" + hash（所有参数）
│  │  ├─ 调用 Cache.Get(cache_key)
│  │  ├─ 如果命中且未过期：
│  │  │  ├─ text_list = 缓存数据
│  │  │  └─ 跳转到步骤 11（构建响应）
│  │  └─ 异常点：Redis 连接失败 → 降级到数据库查询
│  │
│  ├─ 步骤 5：构建数据库查询条件
│  │  ├─ 初始化 filter = {}
│  │  ├─ filter.status = "published"（仅返回已发布的文本）
│  │  ├─ filter.deleted_at = null（未删除）
│  │  ├─ 如果提供 category：
│  │  │  └─ filter.category = category
│  │  ├─ 如果提供 difficulty：
│  │  │  └─ filter.difficulty = difficulty
│  │  ├─ 如果提供 language：
│  │  │  └─ filter.language = language
│  │  ├─ 如果提供 duration_min 和 duration_max：
│  │  │  └─ filter.estimated_duration between duration_min and duration_max
│  │  ├─ 如果提供 phonemes：
│  │  │  ├─ 需要包含所有指定音素的文本
│  │  │  └─ filter.phonemes contains all(phonemes)
│  │  ├─ 如果提供 tag：
│  │  │  ├─ 需要包含任意指定标签的文本
│  │  │  └─ filter.tags contains any(tags)
│  │  ├─ 如果提供 search：
│  │  │  ├─ 需要全文搜索
│  │  │  ├─ filter.content like search 或 filter.title like search
│  │  │  └─ 可能需要使用全文索引或搜索引擎
│  │  ├─ 如果 include_learned == false 且 user_id 存在：
│  │  │  ├─ 排除用户已掌握的文本（learning_status == "mastered"）
│  │  │  └─ 构建子查询排除条件
│  │  └─ 异常处理：条件构建失败 → 返回 400
│  │
│  ├─ 步骤 6：查询文本总数
│  │  ├─ 调用 Database.CountTexts(filter)
│  │  ├─ 返回：total（总记录数）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 7：计算分页信息
│  │  ├─ total_pages = ceil(total / page_size)
│  │  ├─ 检查 page 是否超出范围
│  │  │  └─ 异常点：page > total_pages 且 total > 0 → 返回 400
│  │  ├─ 如果 total == 0：
│  │  │  └─ 返回空列表，total_pages = 0
│  │  └─ 继续查询数据
│  │
│  ├─ 步骤 8：排序设置
│  │  ├─ 如果提供 search，默认排序为 relevance（搜索相关度）
│  │  │  └─ 使用搜索引擎的相关度排序
│  │  ├─ 否则按 sort_by 排序：
│  │  │  ├─ "difficulty"：按难度升序
│  │  │  ├─ "popularity"：按学习人数降序
│  │  │  ├─ "newest"：按创建时间降序
│  │  │  └─ "relevance"（默认）：按热度降序
│  │  └─ 异常处理：排序失败 → 使用默认排序
│  │
│  ├─ 步骤 9：从数据库查询文本列表
│  │  ├─ 调用 Database.GetTexts(filter, offset, page_size, sort_by, sort_order)
│  │  ├─ 返回：texts[]，每条包含：
│  │  │  ├─ text_id
│  │  │  ├─ content
│  │  │  ├─ title（可选）
│  │  │  ├─ category
│  │  │  ├─ difficulty
│  │  │  ├─ language
│  │  │  ├─ estimated_duration_seconds
│  │  │  ├─ phonemes[]（包含的拼音/音素列表）
│  │  │  ├─ tags[]
│  │  │  ├─ source（来源）
│  │  │  ├─ created_at
│  │  │  ├─ study_count（已被学习的人数）
│  │  │  ├─ average_score（平均评分，如有）
│  │  │  └─ audio_url（可选）
│  │  └─ 异常点：数据库查询失败 → 返回 500
│  │
│  ├─ 步骤 10：丰富化数据（如已认证）
│  │  ├─ 如果 user_id 存在：
│  │  │  ├─ 对每条文本，查询用户的学习状态：
│  │  │  │  ├─ 调用 Database.GetUserTextProgress(user_id, text_id)
│  │  │  │  ├─ 返回：learning_status, practice_count, best_score, last_practice_at
│  │  │  │  └─ 异常处理：查询失败 → 返回 null（学习状态）
│  │  │  ├─ 对每条文本，添加用户相关信息：
│  │  │  │  ├─ is_learned：用户是否已掌握
│  │  │  │  ├─ user_best_score
│  │  │  │  ├─ practice_count
│  │  │  │  └─ last_practiced_at
│  │  │  └─ 异常处理：批量查询失败 → 返回不完整数据
│  │  └─ 否则跳过（匿名用户）
│  │
│  ├─ 步骤 11：构建响应体
│  │  ├─ 响应结构：
│  │  │  ├─ code = 200
│  │  │  ├─ message = "success"
│  │  │  └─ data = {
│  │  │      items: [
│  │  │        {
│  │  │          text_id,
│  │  │          content,
│  │  │          title,
│  │  │          category,
│  │  │          difficulty,
│  │  │          language,
│  │  │          estimated_duration_seconds,
│  │  │          phonemes,
│  │  │          tags,
│  │  │          study_count,
│  │  │          average_score,
│  │  │          
│  │  │          user_progress（如已认证）: {
│  │  │            is_learned,
│  │  │            user_best_score,
│  │  │            practice_count,
│  │  │            last_practiced_at
│  │  │          }
│  │  │        },
│  │  │        ...
│  │  │      ],
│  │  │      
│  │  │      pagination: {
│  │  │        page,
│  │  │        page_size,
│  │  │        total,
│  │  │        total_pages
│  │  │      },
│  │  │      
│  │  │      filters_applied: {
│  │  │        search,
│  │  │        category,
│  │  │        difficulty,
│  │  │        language,
│  │  │        ...（所有应用的过滤条件）
│  │  │      },
│  │  │      
│  │  │      available_filters: {
│  │  │        categories: [ "daily", "story", ... ],
│  │  │        difficulties: [ "easy", "medium", ... ],
│  │  │        languages: [ "zh_CN", "zh_TW", ... ],
│  │  │        tags: [ "日常对话", "故事", ... ]（热门标签）
│  │  │      }
│  │  │    }
│  │  └─ HTTP 状态码：200 OK
│  │
│  ├─ 步骤 12：缓存查询结果
│  │  ├─ 调用 Cache.Set(cache_key, 响应数据, TTL=1小时)
│  │  │  └─ 文本库数据变化不频繁，可以使用较长 TTL
│  │  └─ 异常处理：缓存设置失败 → 记录日志，继续
│  │
│  ├─ 步骤 13：记录搜索分析（可选）
│  │  ├─ 如果提供了 search：
│  │  │  ├─ 调用 Analytics.LogSearch({
│  │  │  │  search_query: search,
│  │  │  │  result_count: total,
│  │  │  │  user_id: user_id（如有）,
│  │  │  │  timestamp: now
│  │  │  │})
│  │  │  └─ 异步记录（不阻塞）
│  │  └─ 异常处理：记录失败 → 继续（非关键）
│  │
│  └─ 步骤 14：返回响应
│     └─ 返回 JSON 响应给客户端
│
└─ 流程结束
```

---

### 7.2 异常处理总结

| 异常点 | 处理方式 | 用户感知 | HTTP 状态码 |
|--------|---------|---------|-----------|
| 分页参数非法 | 返回 400 | 参数错误 | 400 |
| 搜索词过长 | 返回 400 | 参数错误 | 400 |
| 无效的分类/难度 | 返回 400 | 参数错误 | 400 |
| 页码超出范围 | 返回 400 | 参数错误 | 400 |
| Redis 连接失败 | 降级到数据库 | 查询可能变慢 | 200 |
| 数据库查询失败 | 返回 500 | 系统错误 | 500 |
| 用户进度查询失败 | 返回不完整数据 | 部分功能缺失 | 200 |

---

## 八、综合总结表

### 8.1 接口特性对比

| 接口 | 同步/异步 | 操作类型 | 关键步骤数 | 异常点数 | 第三方 API |
|------|---------|---------|----------|--------|-----------|
| POST /auth/login | 同步 | 认证 | 17 | 12 | 2 个（SMS, Email） |
| POST /auth/register | 同步+异步 | 创建账户 | 16 + 3 | 13 | 1 个（Email） |
| POST /auth/logout | 同步 | 撤销令牌 | 15 | 8 | 0 个 |
| POST /auth/refresh | 同步 | 令牌刷新 | 14 | 10 | 0 个 |
| GET /user/profile | 同步 | 查询资料 | 12 | 6 | 0 个 |
| PUT /user/profile | 同步 | 更新资料 | 21 | 10 | 1 个（OSS） |
| GET /resources/texts | 同步 | 搜索文本 | 14 | 8 | 0 个 |

---

### 8.2 数据存储涉及的系统

| 接口 | MySQL | Redis | OSS | 队列 |
|------|--------|-------|-----|------|
| POST /auth/login | ✓ | ✓ | - | - |
| POST /auth/register | ✓ | ✓ | - | ✓（邮件） |
| POST /auth/logout | ✓ | ✓ | - | - |
| POST /auth/refresh | ✓ | ✓ | - | - |
| GET /user/profile | ✓ | ✓ | - | - |
| PUT /user/profile | ✓ | ✓ | ✓ | - |
| GET /resources/texts | ✓ | ✓ | - | - |

---

### 8.3 缓存策略总结

| 缓存键 | TTL | 更新时机 | 清除时机 |
|--------|-----|---------|---------|
| login_fail:{account} | 15 分钟 | 登录失败时 | 自动过期 |
| login_lock:{account} | 15 分钟 | 锁定时 | 自动过期 |
| refresh_token:{user_id}:{token_id} | 90 天 | 登录时 | 登出或撤销时 |
| session:{session_id} | token 有效期 | 登录时 | 登出时 |
| email_verify:{user_id} | 24 小时 | 注册时 | 验证成功后 |
| token_blacklist:{token_hash} | token 有效期 | 登出时 | 自动过期 |
| token_refresh:{token_hash} | 1 分钟 | 刷新时 | 自动过期 |
| user:{user_id} | 24 小时 | 登录后 | 用户更新时 |
| texts:list:{hash} | 1 小时 | 查询后 | 文本库更新时 |

---

### 8.4 安全特性总结

| 功能 | 实现方式 | 保护的威胁 |
|------|--------|----------|
| 速率限制 | IP+账户双限制 | 暴力破解、DDoS |
| 密码加盐加密 | bcrypt/PBKDF2 | 密码泄露 |
| JWT 签署 | HMAC/RSA | 令牌伪造 |
| MFA（可选） | SMS/Email/Authenticator | 账户被盗 |
| 令牌黑名单 | Redis 缓存 | 令牌被盗后恶意使用 |
| 审计日志 | 数据库记录 | 事后追查、违规检测 |
| HTTP Header 安全 | HttpOnly, Secure, SameSite | XSS、CSRF、网络嗅探 |
| HTTPS 要求 | TLS 加密 | 中间人攻击 |

---

## 九、关键设计决策说明

### 9.1 为什么登录需要那么多异常处理步骤？

**原因**：
1. **安全性**：防止暴力破解、账户枚举等攻击
2. **用户体验**：提供明确的错误反馈和账户保护
3. **审计**：记录所有登录尝试便于安全审查
4. **灵活性**：支持 MFA 等高级安全功能

### 9.2 为什么注册需要邮箱验证？

**原因**：
1. **防止滥用**：确保邮箱真实有效
2. **账户恢复**：允许用户通过邮箱重置密码
3. **通知**：用于向用户发送重要通知
4. **防垃圾**：避免虚假账户注册

### 9.3 为什么修改密码需要撤销其他会话？

**原因**：
1. **安全性**：如果密码被盗，需要立即断开其他设备的连接
2. **强制更新**：确保所有活跃会话都使用新的身份验证
3. **防控**：阻止未授权设备的继续访问

### 9.4 为什么文本搜索支持这么多过滤条件？

**原因**：
1. **个性化学习**：用户可根据自己的需求选择内容
2. **循序渐进**：按难度过滤便于循序渐进学习
3. **针对性练习**：按音素过滤便于针对性纠正发音
4. **灵活性**：多种组合满足不同学习场景

### 9.5 为什么需要用户学习进度缓存？

**原因**：
1. **性能**：避免每次搜索都查询用户进度
2. **实时性**：结合 TTL 保证数据不过期
3. **可扩展性**：支持大量并发用户查询
4. **成本**：减少数据库查询负载

---

## 十、伪代码规范说明

本伪代码遵循以下规范：

1. **缩进**：表示层级关系和逻辑块
2. **异常点**：标记为 `异常点：条件 → 处理`
3. **API 调用**：标记为 `第三方 API 调用点：服务名`
4. **同步 vs 异步**：在流程开始明确标注
5. **变量赋值**：使用 `变量名 = 函数()` 格式
6. **条件分支**：使用 `【情况 A】`、`【情况 B】` 等标注
7. **事务**：使用 `BeginTransaction()` 等标注
8. **HTTP 状态码**：标注每个返回分支的状态码
9. **缓存策略**：明确标注 TTL 和清除时机
10. **安全机制**：标注防护措施和保护的威胁

---

**通用接口核心流程伪代码已完成！** 🎉

现在已完成以下模块的详细伪代码：
- ✅ Chat 模块（5 个接口）
- ✅ Evaluate 模块（6 个接口）
- ✅ Report 模块（6 个接口）
- ✅ 通用接口（7 个接口）

**总计：24 个接口的完整核心流程伪代码**